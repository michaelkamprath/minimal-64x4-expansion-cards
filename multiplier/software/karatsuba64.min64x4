; The Karatsuba algorithm is a way rudcing the number of multiplications that are needed to
; multiply large numbers when the low level multiplier (hardware or even software) operates
; on word sizes that are smaller than than the numbers being multiplied. It speeds things up
; when the cost of the multiplication is much higher than the cost of addition.
;
; Consider values A and B each of bit size X, then they can be re-expressed in terms of their nibbles:
;   A = A1*2^(X/2)|A0*2^0
;   B = B1*2^(X/2)|B0*2^0
;
; Then multiplying A*B can be expressed as:
;
;   R = (A1*B1*2^X|A0*B0*2^0) + (A1*B0 + A0*B1)*2^(X/2)
;
; Using bit placement when doing this multiplication to effect the 2^X and 2^(X/2) factors, then ther
; are 4 multiplication and 2 additions in this formula. The OR operation isn't being considered because
; the net effect of this is simply accomplished with bit placement of the results. If the multiplications
; are much more expensive than the additions, then finding a way to reduce the multiplications would
; benefit the speed here. This is what the  Karatsuba accomplishes.
;
; It starts with the observation that the middle term (A1*B0 + A0*B1) can be algebraically rewritten as:
;
;   (A1*B0 + A0*B1) = (A1 + A0)*(B1 + B0) - A1*B1 - A0*B0
;
; When you notice that A1*B1 and A0*B0 terms need to be calculated already for the other parts of the result
; calculation, this replaces 2 multiplications and 1 addition with 1 multiplication and 4 additions. If the
; multioplications was over 3 times more expensive than the additions, then this form of the equation would
; be calculated faster.
;
; The final results formula would be:
;
;   R = (A1*B1*2^X|A0*B0*2^0) + ((A1 + A0)*(B1 + B0) - A1*B1 - A0*B0)*2^(X/2)
;
; An advantage here is that this equation can be applied recursively. That is, if for example the A1*B1
; multiplication is itself composed of large numbers (admitedly smaller than A*B, but still large), then
; then the Karatsuba algorithm can be used to speed up that multiplication.
;
; As highlighted, the Karatsuba algorithm is less beneficial the closer the cost of multiplication gets to
; 3 times the cost of addittion. If multiplication and addition use the same number of computer clock cycles,
; Then the Karatsuba algorithm will actually perform more slowly because there are more math operations that
; need to be calculated in order to achieve the results.  So the Karatsuba algorithm is nto a universal speed
; up, and shouldn't always be applied. The key is to know what situation you are in.
;
; ### Application to Minimal 64x4 Multiplier Card ###
;
; The multiplier card described in this project repository requires a different number of cloc cycles two
; multiply two value as is requied to add. The typical process to multiply two 8-bit values is (and here we will
; use zero page locations when we can):
;
;       MZB _val_A,MULTIPLIER_A                     ; 7 clock cycles
;       MZB _val_B,MULTIPLIER_B                     ; 7 clock cycles
;       MBZ MULTIPLIER_RESULT_LSB,_mul_result+0     ; 7 clock cycles
;       MBZ MULTIPLIER_RESULT_MSB,_mul_result+1     ; 7 clock cycles
;
; This represents a total of 28 clock cycles. To add two zero page 2-bytes values (which is what is happenign in
; multiplication formulas above when X=16) together and place the results into another zero page locations:
;
;       MVV _val_A,_result                          ; 7 clock cycles
;       AVV _val_B,_result                          ; 14 clock cycles
;
; This is a total of 21 clock cycles. For Karatsuba to be advantageous when directly using the card, the multiplication
; done by the card would need to take 63 or more clock cycles. Clearly it does not here. So for 16-bit multiplications,
; which require 8-bit multiplication of the sub-words and 16-bit addition of the partial products, there is no advantage
; to the Karatsuba algorithm.
;
; For 64-bit multiplication with a 16-bit base case (no further recursion):
;   Schoolbook: 4x 32-bit schoolbook = 16x 16-bit multiplies, 8x 32-bit adds, plus 2x 64-bit adds.
;   Karatsuba: 3x 32-bit Karatsuba = 9x 16-bit multiplies, 6x 16-bit adds,
;              14x 32-bit adds/subs, plus 4x 64-bit adds/subs.
;
; Using 16-bit add ~= 21 cycles, assume 32-bit add ~= 2x (42) and 64-bit add ~= 2x (84):
;   Schoolbook add cost ~= 8*42 + 2*84 = 504 cycles (adds only).
;   Karatsuba add cost ~= 6*21 + 14*42 + 4*84 = 1050 cycles (adds only).
;
; From _multiplication16, a 16-bit multiply uses two direct 8-bit multiplies (2*28) plus two cross terms
; (2*(7+7+5+4+5+4+2+4)) ~= 132 cycles:
;   Schoolbook multiply cost ~= 16*132 = 2112 cycles.
;   Karatsuba multiply cost ~= 9*132  = 1188 cycles.
;
; So total estimated cost (adds + multiplies):
;   Schoolbook ~= 2112 + 504  = 2616 cycles.
;   Karatsuba  ~= 1188 + 1050 = 2238 cycles.
;
; Karatsuba saves 7x 16-bit multiplies at the expense of extra adds; that trade is unfavorable at 16-bit,
; but favorable at 64-bit because though 16-bit multiply is slightly more expensive than a 16-bit add, when
; aggregated many times that expense adds up. Of course this analysis ignores overhead costs, such as memory
; movement, so it's intended to be directional rather than precise.
;
; ### Demostration of Karatsuba Algorithm ###
;
#require "slu4-min64x4-asm >= 1.1.0"
; Keep data out of $8000-$9FFF (reserved for application code).
DATA_START  = $A000
DATA_LENGTH = $4000
PAIR_COUNT  = DATA_LENGTH / 16
OUTER_COUNT = $0050
#ifdef STATUS_BARS
STATUS_WIDTH = 48
FILL_CHUNK = DATA_LENGTH / STATUS_WIDTH
WORK_TOTAL = PAIR_COUNT * OUTER_COUNT
WORK_CHUNK = WORK_TOTAL / STATUS_WIDTH
#endif

.memzone ZERO_PAGE_APPS
#mute
_data_ptr:         .2byte 0
_fill_counter:     .2byte 0
_pair_counter:     .2byte 0
_outer_counter:    .2byte 0
#ifdef STATUS_BARS
_progress_counter: .2byte 0
_progress_reload:  .2byte 0
_progress_stars:   .byte 0
#endif
#emit

.memzone ZERO_PAGE_LIBS
#mute
#emit

.memzone USER_APPS
main:
    SPINIT
    JPS _Clear
    MIZ 0,_XPos
    MIZ 0,_YPos
    JPS _Print "64-bit multiply speed test\n"
    JPS _Print "Filling random data\n\n"

    MIV DATA_START,_data_ptr
    MIV DATA_LENGTH,_fill_counter
#ifdef STATUS_BARS
    MIV FILL_CHUNK,_progress_reload
    MIV FILL_CHUNK,_progress_counter
    MIZ STATUS_WIDTH,_progress_stars
#endif
.fill_loop:
    JPS _Random
    STT _data_ptr
    INV _data_ptr
    DEV _fill_counter
#ifdef STATUS_BARS
    JPS progress_tick
#endif
    CIZ 0,_fill_counter+1
    BNE .fill_loop
    CIZ 0,_fill_counter+0
    BNE .fill_loop

    JPS _Print "\n\nStart schoolbook multiplication\n\n"
    JPS run_schoolbook_workload
    JPS _Print "\n\nEnd schoolbook multiplication\n\n"

    JPS _Print "Press any key to continue >"
    JPS _WaitInput

    JPS _Print "\n\nStart Karatsuba multiplication\n\n"
    JPS run_karatsuba_workload
    JPS _Print "\n\nEnd Karatsuba multiplication\n\n"

    JPS _WaitInput
    JPS _Prompt

run_schoolbook_workload:
    MIV OUTER_COUNT,_outer_counter
#ifdef STATUS_BARS
    MIV WORK_CHUNK,_progress_reload
    MIV WORK_CHUNK,_progress_counter
    MIZ STATUS_WIDTH,_progress_stars
#endif
.schoolbook_outer:
    MIV DATA_START,_data_ptr
    MIV PAIR_COUNT,_pair_counter
.schoolbook_inner:
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    JPS sb64_unsigned_multiply
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    DEV _pair_counter
#ifdef STATUS_BARS
    JPS progress_tick
#endif
    CIZ 0,_pair_counter+1
    BNE .schoolbook_inner
    CIZ 0,_pair_counter+0
    BNE .schoolbook_inner
    DEV _outer_counter
    CIZ 0,_outer_counter+1
    BNE .schoolbook_outer
    CIZ 0,_outer_counter+0
    BNE .schoolbook_outer
    RTS

run_karatsuba_workload:
    MIV OUTER_COUNT,_outer_counter
#ifdef STATUS_BARS
    MIV WORK_CHUNK,_progress_reload
    MIV WORK_CHUNK,_progress_counter
    MIZ STATUS_WIDTH,_progress_stars
#endif
.karatsuba_outer:
    MIV DATA_START,_data_ptr
    MIV PAIR_COUNT,_pair_counter
.karatsuba_inner:
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    JPS ka64_unsigned_multiply
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    DEV _pair_counter
#ifdef STATUS_BARS
    JPS progress_tick
#endif
    CIZ 0,_pair_counter+1
    BNE .karatsuba_inner
    CIZ 0,_pair_counter+0
    BNE .karatsuba_inner
    DEV _outer_counter
    CIZ 0,_outer_counter+1
    BNE .karatsuba_outer
    CIZ 0,_outer_counter+0
    BNE .karatsuba_outer
    RTS

#include "karatsuba64_shared.min64x4"

#ifdef STATUS_BARS
; progress_tick
;
; Decrements the progress counter and prints '*' when it reaches zero.
progress_tick:
    LDZ _progress_stars
    CPI 0
    BEQ .done
    DEV _progress_counter
    CIZ 0,_progress_counter+1
    BNE .done
    CIZ 0,_progress_counter+0
    BNE .done
    MVV _progress_reload,_progress_counter
    LDI '*'
    JAS _PrintChar
    DEZ _progress_stars
.done:
    RTS
#endif
