; The Karatsuba algorithm is a way rudcing the number of multiplications that are needed to
; multiply large numbers when the low level multiplier (hardware or even software) operates
; on word sizes that are smaller than than the numbers being multiplied. It speeds things up
; when the cost of the multiplication is much higher than the cost of addition.
;
; Consider values A and B each of bit size X, then they can be re-expressed in terms of their nibbles:
;   A = A1*2^(X/2)|A0*2^0
;   B = B1*2^(X/2)|B0*2^0
;
; Then multiplying A*B can be expressed as:
;
;   R = (A1*B1*2^X|A0*B0*2^0) + (A1*B0 + A0*B1)*2^(X/2)
;
; Using bit placement when doing this multiplication to effect the 2^X and 2^(X/2) factors, then ther
; are 4 multiplication and 2 additions in this formula. The OR operation isn't being considered because
; the net effect of this is simply accomplished with bit placement of the results. If the multiplications
; are much more expensive than the additions, then finding a way to reduce the multiplications would
; benefit the speed here. This is what the  Karatsuba accomplishes.
;
; It starts with the observation that the middle term (A1*B0 + A0*B1) can be algebraically rewritten as:
;
;   (A1*B0 + A0*B1) = (A1 + A0)*(B1 + B0) - A1*B1 - A0*B0
;
; When you notice that A1*B1 and A0*B0 terms need to be calculated already for the other parts of the result
; calculation, this replaces 2 multiplications and 1 addition with 1 multiplication and 4 additions. If the
; multioplications was over 3 times more expensive than the additions, then this form of the equation would
; be calculated faster.
;
; The final results formula would be:
;
;   R = (A1*B1*2^X|A0*B0*2^0) + ((A1 + A0)*(B1 + B0) - A1*B1 - A0*B0)*2^(X/2)
;
; An advantage here is that this equation can be applied recursively. That is, if for example the A1*B1
; multiplication is itself composed of large numbers (admitedly smaller than A*B, but still large), then
; then the Karatsuba algorithm can be used to speed up that multiplication.
;
; As highlighted, the Karatsuba algorithm is less beneficial the closer the cost of multiplication gets to
; 3 times the cost of addittion. If multiplication and addition use the same number of computer clock cycles,
; Then the Karatsuba algorithm will actually perform more slowly because there are more math operations that
; need to be calculated in order to achieve the results.  So the Karatsuba algorithm is nto a universal speed
; up, and shouldn't always be applied. The key is to know what situation you are in.
;
; ### Application to Minimal 64x4 Multiplier Card ###
;
; The multiplier card described in this project repository requires a different number of cloc cycles two
; multiply two value as is requied to add. The typical process to multiply two 8-bit values is (and here we will
; use zero page locations when we can):
;
;       MZB _val_A,MULTIPLIER_A                     ; 7 clock cycles
;       MZB _val_B,MULTIPLIER_B                     ; 7 clock cycles
;       MBZ MULTIPLIER_RESULT_LSB,_mul_result+0     ; 7 clock cycles
;       MBZ MULTIPLIER_RESULT_MSB,_mul_result+1     ; 7 clock cycles
;
; This represents a total of 28 clock cycles. To add two zero page 2-bytes values (which is what is happenign in
; multiplication formulas above when X=16) together and place the results into another zero page locations:
;
;       MVV _val_A,_result                          ; 7 clock cycles
;       AVV _val_B,_result                          ; 14 clock cycles
;
; This is a total of 21 clock cycles. For Karatsuba to be advantageous when directly using the card, the multiplication
; done by the card would need to take 63 or more clock cycles. Clearly it does not here. So for 16-bit multiplications,
; which require 8-bit multiplication of the sub-words and 16-bit addition of the partial products, there is no advantage
; to the Karatsuba algorithm.
;
; For 64-bit multiplication with a 16-bit base case (no further recursion):
;   Schoolbook: 4x 32-bit schoolbook = 16x 16-bit multiplies, 8x 32-bit adds, plus 2x 64-bit adds.
;   Karatsuba: 3x 32-bit Karatsuba = 9x 16-bit multiplies, 6x 16-bit adds,
;              14x 32-bit adds/subs, plus 4x 64-bit adds/subs.
;
; Using 16-bit add ~= 21 cycles, assume 32-bit add ~= 2x (42) and 64-bit add ~= 2x (84):
;   Schoolbook add cost ~= 8*42 + 2*84 = 504 cycles (adds only).
;   Karatsuba add cost ~= 6*21 + 14*42 + 4*84 = 1050 cycles (adds only).
;
; From _multiplication16, a 16-bit multiply uses two direct 8-bit multiplies (2*28) plus two cross terms
; (2*(7+7+5+4+5+4+2+4)) ~= 132 cycles:
;   Schoolbook multiply cost ~= 16*132 = 2112 cycles.
;   Karatsuba multiply cost ~= 9*132  = 1188 cycles.
;
; So total estimated cost (adds + multiplies):
;   Schoolbook ~= 2112 + 504  = 2616 cycles.
;   Karatsuba  ~= 1188 + 1050 = 2238 cycles.
;
; Karatsuba saves 7x 16-bit multiplies at the expense of extra adds; that trade is unfavorable at 16-bit,
; but favorable at 64-bit because though 16-bit multiply is slightly more expensive than a 16-bit add, when
; aggregated many times that expense adds up. Of course this analysis ignores overhead costs, such as memory
; movement, so it's intended to be directional rather than precise.
;
; ### Demostration of Karatsuba Algorithm ###
;
#require "slu4-min64x4-asm >= 1.1.0"
#use-scope "mathlib32"

; Keep data out of $8000-$9FFF (reserved for application code).
DATA_START  = $A000
DATA_LENGTH = $4000
PAIR_COUNT  = DATA_LENGTH / 16
OUTER_COUNT = $0050
#ifdef STATUS_BARS
STATUS_WIDTH = 48
FILL_CHUNK = DATA_LENGTH / STATUS_WIDTH
WORK_TOTAL = PAIR_COUNT * OUTER_COUNT
WORK_CHUNK = WORK_TOTAL / STATUS_WIDTH
#endif

.memzone ZERO_PAGE_APPS
#mute
_data_ptr:         .2byte 0
_fill_counter:     .2byte 0
_pair_counter:     .2byte 0
_outer_counter:    .2byte 0
_mul64_result:     .16byte 0
_mul64_p:          .8byte 0
_mul64_sumA:       .4byte 0
_mul64_sumB:       .4byte 0
_mul64_sumA_carry: .byte 0
_mul64_sumB_carry: .byte 0
_mul64_p_hi:       .byte 0
#ifdef STATUS_BARS
_progress_counter: .2byte 0
_progress_reload:  .2byte 0
_progress_stars:   .byte 0
#endif
#emit

.memzone ZERO_PAGE_LIBS
#mute
_mul64_op1:        .8byte 0
_mul64_op2:        .8byte 0
#emit

.memzone USER_APPS
main:
    SPINIT
    JPS _Clear
    MIZ 0,_XPos
    MIZ 0,_YPos
    JPS _Print "64-bit multiply speed test\n"
    JPS _Print "Filling random data\n\n"

    MIV DATA_START,_data_ptr
    MIV DATA_LENGTH,_fill_counter
#ifdef STATUS_BARS
    MIV FILL_CHUNK,_progress_reload
    MIV FILL_CHUNK,_progress_counter
    MIZ STATUS_WIDTH,_progress_stars
#endif
.fill_loop:
    JPS _Random
    STT _data_ptr
    INV _data_ptr
    DEV _fill_counter
#ifdef STATUS_BARS
    JPS progress_tick
#endif
    CIZ 0,_fill_counter+1
    BNE .fill_loop
    CIZ 0,_fill_counter+0
    BNE .fill_loop

    JPS _Print "\n\nStart schoolbook multiplication\n\n"
    JPS run_schoolbook_workload
    JPS _Print "\n\nEnd schoolbook multiplication\n\n"

    JPS _Print "Press any key to continue >"
    JPS _WaitInput

    JPS _Print "\n\nStart Karatsuba multiplication\n\n"
    JPS run_karatsuba_workload
    JPS _Print "\n\nEnd Karatsuba multiplication\n\n"

    JPS _WaitInput
    JPS _Prompt

run_schoolbook_workload:
    MIV OUTER_COUNT,_outer_counter
#ifdef STATUS_BARS
    MIV WORK_CHUNK,_progress_reload
    MIV WORK_CHUNK,_progress_counter
    MIZ STATUS_WIDTH,_progress_stars
#endif
.schoolbook_outer:
    MIV DATA_START,_data_ptr
    MIV PAIR_COUNT,_pair_counter
.schoolbook_inner:
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    JPS sb64_unsigned_multiply
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    DEV _pair_counter
#ifdef STATUS_BARS
    JPS progress_tick
#endif
    CIZ 0,_pair_counter+1
    BNE .schoolbook_inner
    CIZ 0,_pair_counter+0
    BNE .schoolbook_inner
    DEV _outer_counter
    CIZ 0,_outer_counter+1
    BNE .schoolbook_outer
    CIZ 0,_outer_counter+0
    BNE .schoolbook_outer
    RTS

run_karatsuba_workload:
    MIV OUTER_COUNT,_outer_counter
#ifdef STATUS_BARS
    MIV WORK_CHUNK,_progress_reload
    MIV WORK_CHUNK,_progress_counter
    MIZ STATUS_WIDTH,_progress_stars
#endif
.karatsuba_outer:
    MIV DATA_START,_data_ptr
    MIV PAIR_COUNT,_pair_counter
.karatsuba_inner:
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    LDT _data_ptr
    PHS
    INV _data_ptr
    JPS ka64_unsigned_multiply
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    DEV _pair_counter
#ifdef STATUS_BARS
    JPS progress_tick
#endif
    CIZ 0,_pair_counter+1
    BNE .karatsuba_inner
    CIZ 0,_pair_counter+0
    BNE .karatsuba_inner
    DEV _outer_counter
    CIZ 0,_outer_counter+1
    BNE .karatsuba_outer
    CIZ 0,_outer_counter+0
    BNE .karatsuba_outer
    RTS

; sb64_unsigned_multiply
; Schoolbook 64-bit multiply using hardware 32-bit core (ml32).
; Stack: SP+3..10=multiplier, SP+11..18=multiplicand (MSB at lower address)
; Result overwrites both inputs on the stack.
sb64_unsigned_multiply:
    LDS 18
    STZ _mul64_op1+0
    LDS 17
    STZ _mul64_op1+1
    LDS 16
    STZ _mul64_op1+2
    LDS 15
    STZ _mul64_op1+3
    LDS 14
    STZ _mul64_op1+4
    LDS 13
    STZ _mul64_op1+5
    LDS 12
    STZ _mul64_op1+6
    LDS 11
    STZ _mul64_op1+7

    LDS 10
    STZ _mul64_op2+0
    LDS 9
    STZ _mul64_op2+1
    LDS 8
    STZ _mul64_op2+2
    LDS 7
    STZ _mul64_op2+3
    LDS 6
    STZ _mul64_op2+4
    LDS 5
    STZ _mul64_op2+5
    LDS 4
    STZ _mul64_op2+6
    LDS 3
    STZ _mul64_op2+7

    JPS _sb_multiplication64_schoolbook

    LDZ _mul64_result+15
    STS 3
    LDZ _mul64_result+14
    STS 4
    LDZ _mul64_result+13
    STS 5
    LDZ _mul64_result+12
    STS 6
    LDZ _mul64_result+11
    STS 7
    LDZ _mul64_result+10
    STS 8
    LDZ _mul64_result+9
    STS 9
    LDZ _mul64_result+8
    STS 10
    LDZ _mul64_result+7
    STS 11
    LDZ _mul64_result+6
    STS 12
    LDZ _mul64_result+5
    STS 13
    LDZ _mul64_result+4
    STS 14
    LDZ _mul64_result+3
    STS 15
    LDZ _mul64_result+2
    STS 16
    LDZ _mul64_result+1
    STS 17
    LDZ _mul64_result+0
    STS 18
    RTS

; ka64_unsigned_multiply
; Karatsuba 64-bit multiply using hardware 32-bit core (ml32).
; Stack: SP+3..10=multiplier, SP+11..18=multiplicand (MSB at lower address)
; Result overwrites both inputs on the stack.
ka64_unsigned_multiply:
    LDS 18
    STZ _mul64_op1+0
    LDS 17
    STZ _mul64_op1+1
    LDS 16
    STZ _mul64_op1+2
    LDS 15
    STZ _mul64_op1+3
    LDS 14
    STZ _mul64_op1+4
    LDS 13
    STZ _mul64_op1+5
    LDS 12
    STZ _mul64_op1+6
    LDS 11
    STZ _mul64_op1+7

    LDS 10
    STZ _mul64_op2+0
    LDS 9
    STZ _mul64_op2+1
    LDS 8
    STZ _mul64_op2+2
    LDS 7
    STZ _mul64_op2+3
    LDS 6
    STZ _mul64_op2+4
    LDS 5
    STZ _mul64_op2+5
    LDS 4
    STZ _mul64_op2+6
    LDS 3
    STZ _mul64_op2+7

    JPS _ka_multiplication64_karatsuba

    LDZ _mul64_result+15
    STS 3
    LDZ _mul64_result+14
    STS 4
    LDZ _mul64_result+13
    STS 5
    LDZ _mul64_result+12
    STS 6
    LDZ _mul64_result+11
    STS 7
    LDZ _mul64_result+10
    STS 8
    LDZ _mul64_result+9
    STS 9
    LDZ _mul64_result+8
    STS 10
    LDZ _mul64_result+7
    STS 11
    LDZ _mul64_result+6
    STS 12
    LDZ _mul64_result+5
    STS 13
    LDZ _mul64_result+4
    STS 14
    LDZ _mul64_result+3
    STS 15
    LDZ _mul64_result+2
    STS 16
    LDZ _mul64_result+1
    STS 17
    LDZ _mul64_result+0
    STS 18
    RTS

; _sb_multiplication32_core
; 32-bit schoolbook multiply using hardware 16-bit core.
; Inputs: _mul64_sumA (multiplicand), _mul64_sumB (multiplier)
; Output: _mul64_p (64-bit result)
_sb_multiplication32_core:
    CLQ _mul64_p
    CLQ _mul64_p+4

    ; Z0 = A0 * B0 (offset 0)
    MZB _mul64_sumA+0,MULTIPLIER_A
    MZB _mul64_sumB+0,MULTIPLIER_B
    MBZ MULTIPLIER_RESULT_LSB,_mul64_p+0
    MBZ MULTIPLIER_RESULT_MSB,_mul64_p+1

    MZB _mul64_sumA+1,MULTIPLIER_A
    MZB _mul64_sumB+1,MULTIPLIER_B
    MBZ MULTIPLIER_RESULT_LSB,_mul64_p+2
    MBZ MULTIPLIER_RESULT_MSB,_mul64_p+3

    MZB _mul64_sumA+1,MULTIPLIER_A
    MZB _mul64_sumB+0,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+1
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+2
    LDI 0
    AC.Z _mul64_p+3

    MZB _mul64_sumA+0,MULTIPLIER_A
    MZB _mul64_sumB+1,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+1
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+2
    LDI 0
    AC.Z _mul64_p+3

    ; Z3 = A1 * B1 (offset 4)
    MZB _mul64_sumA+2,MULTIPLIER_A
    MZB _mul64_sumB+2,MULTIPLIER_B
    MBZ MULTIPLIER_RESULT_LSB,_mul64_p+4
    MBZ MULTIPLIER_RESULT_MSB,_mul64_p+5

    MZB _mul64_sumA+3,MULTIPLIER_A
    MZB _mul64_sumB+3,MULTIPLIER_B
    MBZ MULTIPLIER_RESULT_LSB,_mul64_p+6
    MBZ MULTIPLIER_RESULT_MSB,_mul64_p+7

    MZB _mul64_sumA+3,MULTIPLIER_A
    MZB _mul64_sumB+2,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+5
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    MZB _mul64_sumA+2,MULTIPLIER_A
    MZB _mul64_sumB+3,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+5
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    ; Z1 = A0 * B1 (offset 2)
    MZB _mul64_sumA+0,MULTIPLIER_A
    MZB _mul64_sumB+2,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+2
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+3

    MZB _mul64_sumA+1,MULTIPLIER_A
    MZB _mul64_sumB+3,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+4
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+5

    MZB _mul64_sumA+1,MULTIPLIER_A
    MZB _mul64_sumB+2,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+3
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+4
    LDI 0
    AC.Z _mul64_p+5

    MZB _mul64_sumA+0,MULTIPLIER_A
    MZB _mul64_sumB+3,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+3
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+4
    LDI 0
    AC.Z _mul64_p+5

    LDI 0
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    ; Z2 = A1 * B0 (offset 2)
    MZB _mul64_sumA+2,MULTIPLIER_A
    MZB _mul64_sumB+0,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+2
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+3

    MZB _mul64_sumA+3,MULTIPLIER_A
    MZB _mul64_sumB+1,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+4
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+5

    MZB _mul64_sumA+3,MULTIPLIER_A
    MZB _mul64_sumB+0,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+3
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+4
    LDI 0
    AC.Z _mul64_p+5

    MZB _mul64_sumA+2,MULTIPLIER_A
    MZB _mul64_sumB+1,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+3
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+4
    LDI 0
    AC.Z _mul64_p+5

    LDI 0
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    RTS

; sb32_unsigned_multiply_stack
; Schoolbook 32-bit multiply using hardware 16-bit core. Using stack to transfer
; multiplicands and results so that overhead is on par with ml32_unsigned_multiply.
; Stack: SP+3..6=multiplier, SP+7..10=multiplicand (MSB at lower address)
; Result overwrites both inputs on the stack.
sb32_unsigned_multiply_stack:
    ; Copy multiplicand from stack to _mul64_sumA
    LDS 10
    STZ _mul64_sumA+0
    LDS 9
    STZ _mul64_sumA+1
    LDS 8
    STZ _mul64_sumA+2
    LDS 7
    STZ _mul64_sumA+3

    ; Copy multiplier from stack to _mul64_sumB
    LDS 6
    STZ _mul64_sumB+0
    LDS 5
    STZ _mul64_sumB+1
    LDS 4
    STZ _mul64_sumB+2
    LDS 3
    STZ _mul64_sumB+3

    JPS _sb_multiplication32_core

    ; Copy 64-bit result back to stack
    LDZ _mul64_p+7
    STS 3
    LDZ _mul64_p+6
    STS 4
    LDZ _mul64_p+5
    STS 5
    LDZ _mul64_p+4
    STS 6
    LDZ _mul64_p+3
    STS 7
    LDZ _mul64_p+2
    STS 8
    LDZ _mul64_p+1
    STS 9
    LDZ _mul64_p+0
    STS 10
    RTS

; _add64_offset4
; Adds _mul64_p into _mul64_result+4 with carry propagation into +12..+15.
_add64_offset4:
    LDZ _mul64_p+0
    AD.Z _mul64_result+4
    LDZ _mul64_p+1
    AC.Z _mul64_result+5
    LDZ _mul64_p+2
    AC.Z _mul64_result+6
    LDZ _mul64_p+3
    AC.Z _mul64_result+7
    LDZ _mul64_p+4
    AC.Z _mul64_result+8
    LDZ _mul64_p+5
    AC.Z _mul64_result+9
    LDZ _mul64_p+6
    AC.Z _mul64_result+10
    LDZ _mul64_p+7
    AC.Z _mul64_result+11
    LDI 0
    AC.Z _mul64_result+12
    LDI 0
    AC.Z _mul64_result+13
    LDI 0
    AC.Z _mul64_result+14
    LDI 0
    AC.Z _mul64_result+15
    RTS

; _sb_multiplication64_schoolbook
; 64-bit multiply using 4x 32-bit schoolbook products.
_sb_multiplication64_schoolbook:
    CLQ _mul64_result
    CLQ _mul64_result+4
    CLQ _mul64_result+8
    CLQ _mul64_result+12

    ; Z0 = A0 * B0
    LDZ _mul64_op1+0
    PHS
    LDZ _mul64_op1+1
    PHS
    LDZ _mul64_op1+2
    PHS
    LDZ _mul64_op1+3
    PHS
    LDZ _mul64_op2+0
    PHS
    LDZ _mul64_op2+1
    PHS
    LDZ _mul64_op2+2
    PHS
    LDZ _mul64_op2+3
    PHS
    JPS sb32_unsigned_multiply_stack
    LDS 10
    STZ _mul64_result+0
    LDS 9
    STZ _mul64_result+1
    LDS 8
    STZ _mul64_result+2
    LDS 7
    STZ _mul64_result+3
    LDS 6
    STZ _mul64_result+4
    LDS 5
    STZ _mul64_result+5
    LDS 4
    STZ _mul64_result+6
    LDS 3
    STZ _mul64_result+7
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS

    ; Z3 = A1 * B1
    LDZ _mul64_op1+4
    PHS
    LDZ _mul64_op1+5
    PHS
    LDZ _mul64_op1+6
    PHS
    LDZ _mul64_op1+7
    PHS
    LDZ _mul64_op2+4
    PHS
    LDZ _mul64_op2+5
    PHS
    LDZ _mul64_op2+6
    PHS
    LDZ _mul64_op2+7
    PHS
    JPS sb32_unsigned_multiply_stack
    LDS 10
    STZ _mul64_result+8
    LDS 9
    STZ _mul64_result+9
    LDS 8
    STZ _mul64_result+10
    LDS 7
    STZ _mul64_result+11
    LDS 6
    STZ _mul64_result+12
    LDS 5
    STZ _mul64_result+13
    LDS 4
    STZ _mul64_result+14
    LDS 3
    STZ _mul64_result+15
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS

    ; Z1 = A0 * B1
    LDZ _mul64_op1+0
    PHS
    LDZ _mul64_op1+1
    PHS
    LDZ _mul64_op1+2
    PHS
    LDZ _mul64_op1+3
    PHS
    LDZ _mul64_op2+4
    PHS
    LDZ _mul64_op2+5
    PHS
    LDZ _mul64_op2+6
    PHS
    LDZ _mul64_op2+7
    PHS
    JPS sb32_unsigned_multiply_stack
    LDS 10
    STZ _mul64_p+0
    LDS 9
    STZ _mul64_p+1
    LDS 8
    STZ _mul64_p+2
    LDS 7
    STZ _mul64_p+3
    LDS 6
    STZ _mul64_p+4
    LDS 5
    STZ _mul64_p+5
    LDS 4
    STZ _mul64_p+6
    LDS 3
    STZ _mul64_p+7
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    JPS _add64_offset4

    ; Z2 = A1 * B0
    LDZ _mul64_op1+4
    PHS
    LDZ _mul64_op1+5
    PHS
    LDZ _mul64_op1+6
    PHS
    LDZ _mul64_op1+7
    PHS
    LDZ _mul64_op2+0
    PHS
    LDZ _mul64_op2+1
    PHS
    LDZ _mul64_op2+2
    PHS
    LDZ _mul64_op2+3
    PHS
    JPS sb32_unsigned_multiply_stack
    LDS 10
    STZ _mul64_p+0
    LDS 9
    STZ _mul64_p+1
    LDS 8
    STZ _mul64_p+2
    LDS 7
    STZ _mul64_p+3
    LDS 6
    STZ _mul64_p+4
    LDS 5
    STZ _mul64_p+5
    LDS 4
    STZ _mul64_p+6
    LDS 3
    STZ _mul64_p+7
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    JPS _add64_offset4

    RTS

; _ka_multiplication64_karatsuba
; 64-bit multiply using Karatsuba (3x 32-bit products).
.align
_ka_multiplication64_karatsuba:
    ; Z0 = A0 * B0
    LDZ _mul64_op1+0
    PHS
    LDZ _mul64_op1+1
    PHS
    LDZ _mul64_op1+2
    PHS
    LDZ _mul64_op1+3
    PHS
    LDZ _mul64_op2+0
    PHS
    LDZ _mul64_op2+1
    PHS
    LDZ _mul64_op2+2
    PHS
    LDZ _mul64_op2+3
    PHS
    JPS ml32_unsigned_multiply
    LDS 10
    STZ _mul64_result+0
    LDS 9
    STZ _mul64_result+1
    LDS 8
    STZ _mul64_result+2
    LDS 7
    STZ _mul64_result+3
    LDS 6
    STZ _mul64_result+4
    LDS 5
    STZ _mul64_result+5
    LDS 4
    STZ _mul64_result+6
    LDS 3
    STZ _mul64_result+7
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS

    ; Z2 = A1 * B1
    LDZ _mul64_op1+4
    PHS
    LDZ _mul64_op1+5
    PHS
    LDZ _mul64_op1+6
    PHS
    LDZ _mul64_op1+7
    PHS
    LDZ _mul64_op2+4
    PHS
    LDZ _mul64_op2+5
    PHS
    LDZ _mul64_op2+6
    PHS
    LDZ _mul64_op2+7
    PHS
    JPS ml32_unsigned_multiply
    LDS 10
    STZ _mul64_result+8
    LDS 9
    STZ _mul64_result+9
    LDS 8
    STZ _mul64_result+10
    LDS 7
    STZ _mul64_result+11
    LDS 6
    STZ _mul64_result+12
    LDS 5
    STZ _mul64_result+13
    LDS 4
    STZ _mul64_result+14
    LDS 3
    STZ _mul64_result+15
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS

    ; sumA = A0 + A1
    CLZ _mul64_sumA_carry
    MQQ _mul64_op1+0,_mul64_sumA
    LDZ _mul64_op1+4
    AD.Z _mul64_sumA+0
    LDZ _mul64_op1+5
    AC.Z _mul64_sumA+1
    LDZ _mul64_op1+6
    AC.Z _mul64_sumA+2
    LDZ _mul64_op1+7
    AC.Z _mul64_sumA+3
    BCC .no_carry_a
    INZ _mul64_sumA_carry
.no_carry_a:

    ; sumB = B0 + B1
    CLZ _mul64_sumB_carry
    MQQ _mul64_op2+0,_mul64_sumB
    LDZ _mul64_op2+4
    AD.Z _mul64_sumB+0
    LDZ _mul64_op2+5
    AC.Z _mul64_sumB+1
    LDZ _mul64_op2+6
    AC.Z _mul64_sumB+2
    LDZ _mul64_op2+7
    AC.Z _mul64_sumB+3
    BCC .no_carry_b
    INZ _mul64_sumB_carry
.no_carry_b:

    ; P = sumA * sumB
    LDZ _mul64_sumA+0
    PHS
    LDZ _mul64_sumA+1
    PHS
    LDZ _mul64_sumA+2
    PHS
    LDZ _mul64_sumA+3
    PHS
    LDZ _mul64_sumB+0
    PHS
    LDZ _mul64_sumB+1
    PHS
    LDZ _mul64_sumB+2
    PHS
    LDZ _mul64_sumB+3
    PHS
    JPS ml32_unsigned_multiply
    LDS 10
    STZ _mul64_p+0
    LDS 9
    STZ _mul64_p+1
    LDS 8
    STZ _mul64_p+2
    LDS 7
    STZ _mul64_p+3
    LDS 6
    STZ _mul64_p+4
    LDS 5
    STZ _mul64_p+5
    LDS 4
    STZ _mul64_p+6
    LDS 3
    STZ _mul64_p+7
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS

    CLZ _mul64_p_hi

    ; if sumA_carry: add sumB << 32 to P
    CIZ 0, _mul64_sumA_carry
    BEQ .skip_add_b
    LDZ _mul64_sumB+0
    AD.Z _mul64_p+4
    LDZ _mul64_sumB+1
    AC.Z _mul64_p+5
    LDZ _mul64_sumB+2
    AC.Z _mul64_p+6
    LDZ _mul64_sumB+3
    AC.Z _mul64_p+7
    BCC .no_pcarry1
    INZ _mul64_p_hi
.no_pcarry1:
.skip_add_b:

    ; if sumB_carry: add sumA << 32 to P
    CIZ 0, _mul64_sumB_carry
    BEQ .skip_add_a
    LDZ _mul64_sumA+0
    AD.Z _mul64_p+4
    LDZ _mul64_sumA+1
    AC.Z _mul64_p+5
    LDZ _mul64_sumA+2
    AC.Z _mul64_p+6
    LDZ _mul64_sumA+3
    AC.Z _mul64_p+7
    BCC .no_pcarry2
    INZ _mul64_p_hi
.no_pcarry2:
.skip_add_a:

    ; if sumA_carry & sumB_carry: add 1<<64
    CIZ 0, _mul64_sumA_carry
    BEQ .skip_ab
    CIZ 0, _mul64_sumB_carry
    BEQ .skip_ab
    INZ _mul64_p_hi
.skip_ab:

    ; P = P - Z0 (adjust p_hi for borrows)
    LDZ _mul64_result+0
    SU.Z _mul64_p+0
    LDZ _mul64_result+1
    SC.Z _mul64_p+1
    LDZ _mul64_result+2
    SC.Z _mul64_p+2
    LDZ _mul64_result+3
    SC.Z _mul64_p+3
    LDZ _mul64_result+4
    SC.Z _mul64_p+4
    LDZ _mul64_result+5
    SC.Z _mul64_p+5
    LDZ _mul64_result+6
    SC.Z _mul64_p+6
    LDZ _mul64_result+7
    SC.Z _mul64_p+7
    BCS .no_borrow0
.borrow0:
    DEZ _mul64_p_hi
.no_borrow0:

    ; P = P - Z2 (adjust p_hi for borrows)
    LDZ _mul64_result+8
    SU.Z _mul64_p+0
    LDZ _mul64_result+9
    SC.Z _mul64_p+1
    LDZ _mul64_result+10
    SC.Z _mul64_p+2
    LDZ _mul64_result+11
    SC.Z _mul64_p+3
    LDZ _mul64_result+12
    SC.Z _mul64_p+4
    LDZ _mul64_result+13
    SC.Z _mul64_p+5
    LDZ _mul64_result+14
    SC.Z _mul64_p+6
    LDZ _mul64_result+15
    SC.Z _mul64_p+7
    BCS .no_borrow1
.borrow1:
    DEZ _mul64_p_hi
.no_borrow1:

    ; add Z1 (P << 32)
    LDZ _mul64_p+0
    AD.Z _mul64_result+4
    LDZ _mul64_p+1
    AC.Z _mul64_result+5
    LDZ _mul64_p+2
    AC.Z _mul64_result+6
    LDZ _mul64_p+3
    AC.Z _mul64_result+7
    LDZ _mul64_p+4
    AC.Z _mul64_result+8
    LDZ _mul64_p+5
    AC.Z _mul64_result+9
    LDZ _mul64_p+6
    AC.Z _mul64_result+10
    LDZ _mul64_p+7
    AC.Z _mul64_result+11
    LDI 0
    AC.Z _mul64_result+12
    LDI 0
    AC.Z _mul64_result+13
    LDI 0
    AC.Z _mul64_result+14
    LDI 0
    AC.Z _mul64_result+15

    ; add p_hi (extra Z1 bits above 64)
    CLC
    LDZ _mul64_p_hi
    AD.Z _mul64_result+12
    LDI 0
    AC.Z _mul64_result+13
    LDI 0
    AC.Z _mul64_result+14
    LDI 0
    AC.Z _mul64_result+15

    RTS

#ifdef STATUS_BARS
; progress_tick
;
; Decrements the progress counter and prints '*' when it reaches zero.
progress_tick:
    LDZ _progress_stars
    CPI 0
    BEQ .done
    DEV _progress_counter
    CIZ 0,_progress_counter+1
    BNE .done
    CIZ 0,_progress_counter+0
    BNE .done
    MVV _progress_reload,_progress_counter
    LDI '*'
    JAS _PrintChar
    DEZ _progress_stars
.done:
    RTS
#endif




#include "mathlib32.min64x4"
