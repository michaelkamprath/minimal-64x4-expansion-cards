; Shared 64-bit multiply routines (schoolbook + Karatsuba)
; Used by karatsuba64.min64x4 and karatsuba64_test.min64x4

#use-scope "mathlib32"

.memzone ZERO_PAGE_APPS
#mute
_mul64_result:     .16byte 0
_mul64_p:          .8byte 0
_mul64_sumA:       .4byte 0
_mul64_sumB:       .4byte 0
_mul64_sumA_carry: .byte 0
_mul64_sumB_carry: .byte 0
_mul64_p_hi:       .byte 0
#emit

.memzone ZERO_PAGE_LIBS
#mute
_mul64_op1:        .8byte 0
_mul64_op2:        .8byte 0
#emit

.memzone USER_APPS

; sb64_unsigned_multiply
; Schoolbook 64-bit multiply using hardware 32-bit core (ml32).
; Stack: SP+3..10=multiplier, SP+11..18=multiplicand (MSB at lower address)
; Result overwrites both inputs on the stack.
sb64_unsigned_multiply:
    LDS 18
    STZ _mul64_op1+0
    LDS 17
    STZ _mul64_op1+1
    LDS 16
    STZ _mul64_op1+2
    LDS 15
    STZ _mul64_op1+3
    LDS 14
    STZ _mul64_op1+4
    LDS 13
    STZ _mul64_op1+5
    LDS 12
    STZ _mul64_op1+6
    LDS 11
    STZ _mul64_op1+7

    LDS 10
    STZ _mul64_op2+0
    LDS 9
    STZ _mul64_op2+1
    LDS 8
    STZ _mul64_op2+2
    LDS 7
    STZ _mul64_op2+3
    LDS 6
    STZ _mul64_op2+4
    LDS 5
    STZ _mul64_op2+5
    LDS 4
    STZ _mul64_op2+6
    LDS 3
    STZ _mul64_op2+7

    JPS _sb_multiplication64_schoolbook

    LDZ _mul64_result+15
    STS 3
    LDZ _mul64_result+14
    STS 4
    LDZ _mul64_result+13
    STS 5
    LDZ _mul64_result+12
    STS 6
    LDZ _mul64_result+11
    STS 7
    LDZ _mul64_result+10
    STS 8
    LDZ _mul64_result+9
    STS 9
    LDZ _mul64_result+8
    STS 10
    LDZ _mul64_result+7
    STS 11
    LDZ _mul64_result+6
    STS 12
    LDZ _mul64_result+5
    STS 13
    LDZ _mul64_result+4
    STS 14
    LDZ _mul64_result+3
    STS 15
    LDZ _mul64_result+2
    STS 16
    LDZ _mul64_result+1
    STS 17
    LDZ _mul64_result+0
    STS 18
    RTS

; ka64_unsigned_multiply
; Karatsuba 64-bit multiply using hardware 32-bit core (ml32).
; Stack: SP+3..10=multiplier, SP+11..18=multiplicand (MSB at lower address)
; Result overwrites both inputs on the stack.
ka64_unsigned_multiply:
    LDS 18
    STZ _mul64_op1+0
    LDS 17
    STZ _mul64_op1+1
    LDS 16
    STZ _mul64_op1+2
    LDS 15
    STZ _mul64_op1+3
    LDS 14
    STZ _mul64_op1+4
    LDS 13
    STZ _mul64_op1+5
    LDS 12
    STZ _mul64_op1+6
    LDS 11
    STZ _mul64_op1+7

    LDS 10
    STZ _mul64_op2+0
    LDS 9
    STZ _mul64_op2+1
    LDS 8
    STZ _mul64_op2+2
    LDS 7
    STZ _mul64_op2+3
    LDS 6
    STZ _mul64_op2+4
    LDS 5
    STZ _mul64_op2+5
    LDS 4
    STZ _mul64_op2+6
    LDS 3
    STZ _mul64_op2+7

    JPS _ka_multiplication64_karatsuba

    LDZ _mul64_result+15
    STS 3
    LDZ _mul64_result+14
    STS 4
    LDZ _mul64_result+13
    STS 5
    LDZ _mul64_result+12
    STS 6
    LDZ _mul64_result+11
    STS 7
    LDZ _mul64_result+10
    STS 8
    LDZ _mul64_result+9
    STS 9
    LDZ _mul64_result+8
    STS 10
    LDZ _mul64_result+7
    STS 11
    LDZ _mul64_result+6
    STS 12
    LDZ _mul64_result+5
    STS 13
    LDZ _mul64_result+4
    STS 14
    LDZ _mul64_result+3
    STS 15
    LDZ _mul64_result+2
    STS 16
    LDZ _mul64_result+1
    STS 17
    LDZ _mul64_result+0
    STS 18
    RTS

; _sb_multiplication32_core
; 32-bit schoolbook multiply using hardware 16-bit core.
; Inputs: _mul64_sumA (multiplicand), _mul64_sumB (multiplier)
; Output: _mul64_p (64-bit result)
_sb_multiplication32_core:
    CLQ _mul64_p
    CLQ _mul64_p+4

    ; a0 * b0 -> offset 0
    MZB _mul64_sumA+0,MULTIPLIER_A
    MZB _mul64_sumB+0,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+0
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+1
    LDI 0
    AC.Z _mul64_p+2
    LDI 0
    AC.Z _mul64_p+3
    LDI 0
    AC.Z _mul64_p+4
    LDI 0
    AC.Z _mul64_p+5
    LDI 0
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    ; a0 * b1 -> offset 1
    MZB _mul64_sumA+0,MULTIPLIER_A
    MZB _mul64_sumB+1,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+1
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+2
    LDI 0
    AC.Z _mul64_p+3
    LDI 0
    AC.Z _mul64_p+4
    LDI 0
    AC.Z _mul64_p+5
    LDI 0
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    ; a0 * b2 -> offset 2
    MZB _mul64_sumA+0,MULTIPLIER_A
    MZB _mul64_sumB+2,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+2
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+3
    LDI 0
    AC.Z _mul64_p+4
    LDI 0
    AC.Z _mul64_p+5
    LDI 0
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    ; a0 * b3 -> offset 3
    MZB _mul64_sumA+0,MULTIPLIER_A
    MZB _mul64_sumB+3,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+3
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+4
    LDI 0
    AC.Z _mul64_p+5
    LDI 0
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    ; a1 * b0 -> offset 1
    MZB _mul64_sumA+1,MULTIPLIER_A
    MZB _mul64_sumB+0,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+1
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+2
    LDI 0
    AC.Z _mul64_p+3
    LDI 0
    AC.Z _mul64_p+4
    LDI 0
    AC.Z _mul64_p+5
    LDI 0
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    ; a1 * b1 -> offset 2
    MZB _mul64_sumA+1,MULTIPLIER_A
    MZB _mul64_sumB+1,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+2
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+3
    LDI 0
    AC.Z _mul64_p+4
    LDI 0
    AC.Z _mul64_p+5
    LDI 0
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    ; a1 * b2 -> offset 3
    MZB _mul64_sumA+1,MULTIPLIER_A
    MZB _mul64_sumB+2,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+3
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+4
    LDI 0
    AC.Z _mul64_p+5
    LDI 0
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    ; a1 * b3 -> offset 4
    MZB _mul64_sumA+1,MULTIPLIER_A
    MZB _mul64_sumB+3,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+4
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+5
    LDI 0
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    ; a2 * b0 -> offset 2
    MZB _mul64_sumA+2,MULTIPLIER_A
    MZB _mul64_sumB+0,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+2
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+3
    LDI 0
    AC.Z _mul64_p+4
    LDI 0
    AC.Z _mul64_p+5
    LDI 0
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    ; a2 * b1 -> offset 3
    MZB _mul64_sumA+2,MULTIPLIER_A
    MZB _mul64_sumB+1,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+3
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+4
    LDI 0
    AC.Z _mul64_p+5
    LDI 0
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    ; a2 * b2 -> offset 4
    MZB _mul64_sumA+2,MULTIPLIER_A
    MZB _mul64_sumB+2,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+4
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+5
    LDI 0
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    ; a2 * b3 -> offset 5
    MZB _mul64_sumA+2,MULTIPLIER_A
    MZB _mul64_sumB+3,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+5
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    ; a3 * b0 -> offset 3
    MZB _mul64_sumA+3,MULTIPLIER_A
    MZB _mul64_sumB+0,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+3
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+4
    LDI 0
    AC.Z _mul64_p+5
    LDI 0
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    ; a3 * b1 -> offset 4
    MZB _mul64_sumA+3,MULTIPLIER_A
    MZB _mul64_sumB+1,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+4
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+5
    LDI 0
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    ; a3 * b2 -> offset 5
    MZB _mul64_sumA+3,MULTIPLIER_A
    MZB _mul64_sumB+2,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+5
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    ; a3 * b3 -> offset 6
    MZB _mul64_sumA+3,MULTIPLIER_A
    MZB _mul64_sumB+3,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+6
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+7

    RTS

; sb32_unsigned_multiply_stack
; Schoolbook 32-bit multiply using hardware 16-bit core.
; Stack: SP+3..6=multiplier, SP+7..10=multiplicand (MSB at lower address)
; Result overwrites both inputs on the stack.
sb32_unsigned_multiply_stack:
    ; Copy multiplicand from stack to _mul64_sumA
    LDS 10
    STZ _mul64_sumA+0
    LDS 9
    STZ _mul64_sumA+1
    LDS 8
    STZ _mul64_sumA+2
    LDS 7
    STZ _mul64_sumA+3

    ; Copy multiplier from stack to _mul64_sumB
    LDS 6
    STZ _mul64_sumB+0
    LDS 5
    STZ _mul64_sumB+1
    LDS 4
    STZ _mul64_sumB+2
    LDS 3
    STZ _mul64_sumB+3

    JPS _sb_multiplication32_core

    ; Copy 64-bit result back to stack
    LDZ _mul64_p+7
    STS 3
    LDZ _mul64_p+6
    STS 4
    LDZ _mul64_p+5
    STS 5
    LDZ _mul64_p+4
    STS 6
    LDZ _mul64_p+3
    STS 7
    LDZ _mul64_p+2
    STS 8
    LDZ _mul64_p+1
    STS 9
    LDZ _mul64_p+0
    STS 10
    RTS

; _add64_offset4
; Adds _mul64_p into _mul64_result+4 with carry propagation into +12..+15.
_add64_offset4:
    LDZ _mul64_p+0
    AD.Z _mul64_result+4
    LDZ _mul64_p+1
    AC.Z _mul64_result+5
    LDZ _mul64_p+2
    AC.Z _mul64_result+6
    LDZ _mul64_p+3
    AC.Z _mul64_result+7
    LDZ _mul64_p+4
    AC.Z _mul64_result+8
    LDZ _mul64_p+5
    AC.Z _mul64_result+9
    LDZ _mul64_p+6
    AC.Z _mul64_result+10
    LDZ _mul64_p+7
    AC.Z _mul64_result+11
    LDI 0
    AC.Z _mul64_result+12
    LDI 0
    AC.Z _mul64_result+13
    LDI 0
    AC.Z _mul64_result+14
    LDI 0
    AC.Z _mul64_result+15
    RTS

; _sb_multiplication64_schoolbook
; 64-bit multiply using 4x 32-bit schoolbook products.
_sb_multiplication64_schoolbook:
    CLQ _mul64_result
    CLQ _mul64_result+4
    CLQ _mul64_result+8
    CLQ _mul64_result+12

    ; Z0 = A0 * B0
    LDZ _mul64_op1+0
    PHS
    LDZ _mul64_op1+1
    PHS
    LDZ _mul64_op1+2
    PHS
    LDZ _mul64_op1+3
    PHS
    LDZ _mul64_op2+0
    PHS
    LDZ _mul64_op2+1
    PHS
    LDZ _mul64_op2+2
    PHS
    LDZ _mul64_op2+3
    PHS
    JPS sb32_unsigned_multiply_stack
    PLS
    STZ _mul64_result+7
    PLS
    STZ _mul64_result+6
    PLS
    STZ _mul64_result+5
    PLS
    STZ _mul64_result+4
    PLS
    STZ _mul64_result+3
    PLS
    STZ _mul64_result+2
    PLS
    STZ _mul64_result+1
    PLS
    STZ _mul64_result+0

    ; Z3 = A1 * B1
    LDZ _mul64_op1+4
    PHS
    LDZ _mul64_op1+5
    PHS
    LDZ _mul64_op1+6
    PHS
    LDZ _mul64_op1+7
    PHS
    LDZ _mul64_op2+4
    PHS
    LDZ _mul64_op2+5
    PHS
    LDZ _mul64_op2+6
    PHS
    LDZ _mul64_op2+7
    PHS
    JPS sb32_unsigned_multiply_stack
    PLS
    STZ _mul64_result+15
    PLS
    STZ _mul64_result+14
    PLS
    STZ _mul64_result+13
    PLS
    STZ _mul64_result+12
    PLS
    STZ _mul64_result+11
    PLS
    STZ _mul64_result+10
    PLS
    STZ _mul64_result+9
    PLS
    STZ _mul64_result+8

    ; Z1 = A0 * B1
    LDZ _mul64_op1+0
    PHS
    LDZ _mul64_op1+1
    PHS
    LDZ _mul64_op1+2
    PHS
    LDZ _mul64_op1+3
    PHS
    LDZ _mul64_op2+4
    PHS
    LDZ _mul64_op2+5
    PHS
    LDZ _mul64_op2+6
    PHS
    LDZ _mul64_op2+7
    PHS
    JPS sb32_unsigned_multiply_stack
    PLS
    STZ _mul64_p+7
    PLS
    STZ _mul64_p+6
    PLS
    STZ _mul64_p+5
    PLS
    STZ _mul64_p+4
    PLS
    STZ _mul64_p+3
    PLS
    STZ _mul64_p+2
    PLS
    STZ _mul64_p+1
    PLS
    STZ _mul64_p+0
    JPS _add64_offset4

    ; Z2 = A1 * B0
    LDZ _mul64_op1+4
    PHS
    LDZ _mul64_op1+5
    PHS
    LDZ _mul64_op1+6
    PHS
    LDZ _mul64_op1+7
    PHS
    LDZ _mul64_op2+0
    PHS
    LDZ _mul64_op2+1
    PHS
    LDZ _mul64_op2+2
    PHS
    LDZ _mul64_op2+3
    PHS
    JPS sb32_unsigned_multiply_stack
    PLS
    STZ _mul64_p+7
    PLS
    STZ _mul64_p+6
    PLS
    STZ _mul64_p+5
    PLS
    STZ _mul64_p+4
    PLS
    STZ _mul64_p+3
    PLS
    STZ _mul64_p+2
    PLS
    STZ _mul64_p+1
    PLS
    STZ _mul64_p+0
    JPS _add64_offset4

    RTS

; _ka_multiplication64_karatsuba
; 64-bit multiply using Karatsuba (3x 32-bit products).
.align
_ka_multiplication64_karatsuba:
    ; Z0 = A0 * B0
    LDZ _mul64_op1+0
    PHS
    LDZ _mul64_op1+1
    PHS
    LDZ _mul64_op1+2
    PHS
    LDZ _mul64_op1+3
    PHS
    LDZ _mul64_op2+0
    PHS
    LDZ _mul64_op2+1
    PHS
    LDZ _mul64_op2+2
    PHS
    LDZ _mul64_op2+3
    PHS
    JPS ml32_unsigned_multiply
    PLS
    STZ _mul64_result+7
    PLS
    STZ _mul64_result+6
    PLS
    STZ _mul64_result+5
    PLS
    STZ _mul64_result+4
    PLS
    STZ _mul64_result+3
    PLS
    STZ _mul64_result+2
    PLS
    STZ _mul64_result+1
    PLS
    STZ _mul64_result+0

    ; Z2 = A1 * B1
    LDZ _mul64_op1+4
    PHS
    LDZ _mul64_op1+5
    PHS
    LDZ _mul64_op1+6
    PHS
    LDZ _mul64_op1+7
    PHS
    LDZ _mul64_op2+4
    PHS
    LDZ _mul64_op2+5
    PHS
    LDZ _mul64_op2+6
    PHS
    LDZ _mul64_op2+7
    PHS
    JPS ml32_unsigned_multiply
    PLS
    STZ _mul64_result+15
    PLS
    STZ _mul64_result+14
    PLS
    STZ _mul64_result+13
    PLS
    STZ _mul64_result+12
    PLS
    STZ _mul64_result+11
    PLS
    STZ _mul64_result+10
    PLS
    STZ _mul64_result+9
    PLS
    STZ _mul64_result+8

    ; sumA = A0 + A1
    CLZ _mul64_sumA_carry
    MQQ _mul64_op1+0,_mul64_sumA
    LDZ _mul64_op1+4
    AD.Z _mul64_sumA+0
    LDZ _mul64_op1+5
    AC.Z _mul64_sumA+1
    LDZ _mul64_op1+6
    AC.Z _mul64_sumA+2
    LDZ _mul64_op1+7
    AC.Z _mul64_sumA+3
    BCC .no_carry_a
    INZ _mul64_sumA_carry
.no_carry_a:

    ; sumB = B0 + B1
    CLZ _mul64_sumB_carry
    MQQ _mul64_op2+0,_mul64_sumB
    LDZ _mul64_op2+4
    AD.Z _mul64_sumB+0
    LDZ _mul64_op2+5
    AC.Z _mul64_sumB+1
    LDZ _mul64_op2+6
    AC.Z _mul64_sumB+2
    LDZ _mul64_op2+7
    AC.Z _mul64_sumB+3
    BCC .no_carry_b
    INZ _mul64_sumB_carry
.no_carry_b:

    ; P = sumA * sumB
    LDZ _mul64_sumA+0
    PHS
    LDZ _mul64_sumA+1
    PHS
    LDZ _mul64_sumA+2
    PHS
    LDZ _mul64_sumA+3
    PHS
    LDZ _mul64_sumB+0
    PHS
    LDZ _mul64_sumB+1
    PHS
    LDZ _mul64_sumB+2
    PHS
    LDZ _mul64_sumB+3
    PHS
    JPS ml32_unsigned_multiply
    PLS
    STZ _mul64_p+7
    PLS
    STZ _mul64_p+6
    PLS
    STZ _mul64_p+5
    PLS
    STZ _mul64_p+4
    PLS
    STZ _mul64_p+3
    PLS
    STZ _mul64_p+2
    PLS
    STZ _mul64_p+1
    PLS
    STZ _mul64_p+0

    CLZ _mul64_p_hi

    ; if sumA_carry: add sumB << 32 to P
    CIZ 0, _mul64_sumA_carry
    BEQ .skip_add_b
    LDZ _mul64_sumB+0
    AD.Z _mul64_p+4
    LDZ _mul64_sumB+1
    AC.Z _mul64_p+5
    LDZ _mul64_sumB+2
    AC.Z _mul64_p+6
    LDZ _mul64_sumB+3
    AC.Z _mul64_p+7
    BCC .no_pcarry1
    INZ _mul64_p_hi
.no_pcarry1:
.skip_add_b:

    ; if sumB_carry: add sumA << 32 to P
    CIZ 0, _mul64_sumB_carry
    BEQ .skip_add_a
    LDZ _mul64_sumA+0
    AD.Z _mul64_p+4
    LDZ _mul64_sumA+1
    AC.Z _mul64_p+5
    LDZ _mul64_sumA+2
    AC.Z _mul64_p+6
    LDZ _mul64_sumA+3
    AC.Z _mul64_p+7
    BCC .no_pcarry2
    INZ _mul64_p_hi
.no_pcarry2:
.skip_add_a:

    ; if sumA_carry & sumB_carry: add 1<<64
    CIZ 0, _mul64_sumA_carry
    BEQ .skip_ab
    CIZ 0, _mul64_sumB_carry
    BEQ .skip_ab
    INZ _mul64_p_hi
.skip_ab:

    ; P = P - Z0 (adjust p_hi for borrows)
    LDZ _mul64_result+0
    SU.Z _mul64_p+0
    LDZ _mul64_result+1
    SC.Z _mul64_p+1
    LDZ _mul64_result+2
    SC.Z _mul64_p+2
    LDZ _mul64_result+3
    SC.Z _mul64_p+3
    LDZ _mul64_result+4
    SC.Z _mul64_p+4
    LDZ _mul64_result+5
    SC.Z _mul64_p+5
    LDZ _mul64_result+6
    SC.Z _mul64_p+6
    LDZ _mul64_result+7
    SC.Z _mul64_p+7
    BCS .no_borrow0
.borrow0:
    DEZ _mul64_p_hi
.no_borrow0:

    ; P = P - Z2 (adjust p_hi for borrows)
    LDZ _mul64_result+8
    SU.Z _mul64_p+0
    LDZ _mul64_result+9
    SC.Z _mul64_p+1
    LDZ _mul64_result+10
    SC.Z _mul64_p+2
    LDZ _mul64_result+11
    SC.Z _mul64_p+3
    LDZ _mul64_result+12
    SC.Z _mul64_p+4
    LDZ _mul64_result+13
    SC.Z _mul64_p+5
    LDZ _mul64_result+14
    SC.Z _mul64_p+6
    LDZ _mul64_result+15
    SC.Z _mul64_p+7
    BCS .no_borrow1
.borrow1:
    DEZ _mul64_p_hi
.no_borrow1:

    ; add Z1 (P << 32)
    LDZ _mul64_p+0
    AD.Z _mul64_result+4
    LDZ _mul64_p+1
    AC.Z _mul64_result+5
    LDZ _mul64_p+2
    AC.Z _mul64_result+6
    LDZ _mul64_p+3
    AC.Z _mul64_result+7
    LDZ _mul64_p+4
    AC.Z _mul64_result+8
    LDZ _mul64_p+5
    AC.Z _mul64_result+9
    LDZ _mul64_p+6
    AC.Z _mul64_result+10
    LDZ _mul64_p+7
    AC.Z _mul64_result+11
    LDI 0
    AC.Z _mul64_result+12
    LDI 0
    AC.Z _mul64_result+13
    LDI 0
    AC.Z _mul64_result+14
    LDI 0
    AC.Z _mul64_result+15

    ; add p_hi (extra Z1 bits above 64)
    CLC
    LDZ _mul64_p_hi
    AD.Z _mul64_result+12
    LDI 0
    AC.Z _mul64_result+13
    LDI 0
    AC.Z _mul64_result+14
    LDI 0
    AC.Z _mul64_result+15

    RTS

#include "mathlib32.min64x4"
