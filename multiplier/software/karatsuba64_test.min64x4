#require "slu4-min64x4-asm >= 1.1.0"
#use-scope "mathlib32"

#ifndef USE_ACCELERATOR
#error "USE_ACCELERATOR is required to be defined. Please add '-D USE_ACCELERATOR' to compile command."
#endif

; 64-bit Karatsuba vs schoolbook correctness tests.
; Compile with -D USE_ACCELERATOR to enable the hardware 16-bit core.

.memzone ZERO_PAGE_APPS
#mute
_test_index:        .byte 0
_compare_fail:      .byte 0
_a_base:            .2byte 0
_b_base:            .2byte 0
_expect_base:       .2byte 0
_a_ptr:             .2byte 0
_b_ptr:             .2byte 0
_expect_ptr:        .2byte 0
_actual_ptr:        .2byte 0
_cmp_expected_ptr:  .2byte 0
_cmp_actual_ptr:    .2byte 0
_cmp_count:         .byte 0
_print_ptr:         .2byte 0
_print_count:       .byte 0
_ptr_add_count:     .byte 0
_mul64_result:      .16byte 0
_mul64_p:           .8byte 0
_mul64_sumA:        .4byte 0
_mul64_sumB:        .4byte 0
_mul64_sumA_carry:  .byte 0
_mul64_sumB_carry:  .byte 0
_mul64_p_hi:        .byte 0
#emit

.memzone ZERO_PAGE_LIBS
#mute
_mul64_op1:         .8byte 0
_mul64_op2:         .8byte 0
#emit

.memzone USER_APPS
main:
    SPINIT
    JPS _Clear
    MIZ 0,_XPos
    MIZ 0,_YPos
    JPS _Print "Karatsuba 64-bit tests\n"
    CLZ _test_index

    MIV test0_a,_a_base
    MIV test0_b,_b_base
    MIV test0_expect,_expect_base
    JPS run_test
    INZ _test_index

    MIV test1_a,_a_base
    MIV test1_b,_b_base
    MIV test1_expect,_expect_base
    JPS run_test
    INZ _test_index

    MIV test2_a,_a_base
    MIV test2_b,_b_base
    MIV test2_expect,_expect_base
    JPS run_test
    INZ _test_index

    MIV test3_a,_a_base
    MIV test3_b,_b_base
    MIV test3_expect,_expect_base
    JPS run_test
    INZ _test_index

    MIV test4_a,_a_base
    MIV test4_b,_b_base
    MIV test4_expect,_expect_base
    JPS run_test
    INZ _test_index

    MIV test5_a,_a_base
    MIV test5_b,_b_base
    MIV test5_expect,_expect_base
    JPS run_test
    INZ _test_index

    MIV test6_a,_a_base
    MIV test6_b,_b_base
    MIV test6_expect,_expect_base
    JPS run_test
    INZ _test_index

    MIV test7_a,_a_base
    MIV test7_b,_b_base
    MIV test7_expect,_expect_base
    JPS run_test

    JPS _Print "All tests passed\n"
    JPS _WaitInput
    JPS _Prompt

run_test:
    ; Schoolbook
    MVV _a_base,_a_ptr
    MVV _b_base,_b_ptr
    JPS run_sb
    MVV _expect_base,_expect_ptr
    JPS compare_expected
    CIZ 0,_compare_fail
    BNE sb_mismatch

    ; Karatsuba
    MVV _a_base,_a_ptr
    MVV _b_base,_b_ptr
    JPS run_ka
    MVV _expect_base,_expect_ptr
    JPS compare_expected
    CIZ 0,_compare_fail
    BNE ka_mismatch
    RTS

sb_mismatch:
    JPS _Print "SB mismatch in test "
    LDZ _test_index
    JAS _PrintHex
    JPS print_details
    JPS _WaitInput
    JPS _Prompt

ka_mismatch:
    JPS _Print "KA mismatch in test "
    LDZ _test_index
    JAS _PrintHex
    JPS print_details
    JPS _WaitInput
    JPS _Prompt

print_details:
    JPS _Print "\nA = "
    MVV _a_base,_print_ptr
    MIZ 7,_ptr_add_count
    JPS ptr_add
    MIZ 8,_print_count
    JPS print_bytes
    JPS _Print "\nB = "
    MVV _b_base,_print_ptr
    MIZ 7,_ptr_add_count
    JPS ptr_add
    MIZ 8,_print_count
    JPS print_bytes
    JPS _Print "\nExpected = "
    MVV _expect_base,_print_ptr
    MIZ 15,_ptr_add_count
    JPS ptr_add
    MIZ 16,_print_count
    JPS print_bytes
    JPS _Print "\nActual = "
    MIV actual_buf,_print_ptr
    MIZ 15,_ptr_add_count
    JPS ptr_add
    MIZ 16,_print_count
    JPS print_bytes
    JPS _Print "\n"
    RTS

ptr_add:
    CIZ 0,_ptr_add_count
    BEQ .done
.loop:
    INV _print_ptr
    DEZ _ptr_add_count
    BNE .loop
.done:
    RTS

print_bytes:
.loop:
    LDT _print_ptr
    JAS _PrintHex
    DEV _print_ptr
    DEZ _print_count
    BNE .loop
    RTS

run_sb:
    ; Push A (LSB -> MSB)
    LDT _a_ptr
    PHS
    INV _a_ptr
    LDT _a_ptr
    PHS
    INV _a_ptr
    LDT _a_ptr
    PHS
    INV _a_ptr
    LDT _a_ptr
    PHS
    INV _a_ptr
    LDT _a_ptr
    PHS
    INV _a_ptr
    LDT _a_ptr
    PHS
    INV _a_ptr
    LDT _a_ptr
    PHS
    INV _a_ptr
    LDT _a_ptr
    PHS
    INV _a_ptr

    ; Push B (LSB -> MSB)
    LDT _b_ptr
    PHS
    INV _b_ptr
    LDT _b_ptr
    PHS
    INV _b_ptr
    LDT _b_ptr
    PHS
    INV _b_ptr
    LDT _b_ptr
    PHS
    INV _b_ptr
    LDT _b_ptr
    PHS
    INV _b_ptr
    LDT _b_ptr
    PHS
    INV _b_ptr
    LDT _b_ptr
    PHS
    INV _b_ptr
    LDT _b_ptr
    PHS
    INV _b_ptr

    JPS sb64_unsigned_multiply

    MIV actual_buf,_actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    MIZ 16,_cmp_count
.pop_loop:
    PLS
    STT _actual_ptr
    DEV _actual_ptr
    DEZ _cmp_count
    BNE .pop_loop
    RTS

run_ka:
    ; Push A (LSB -> MSB)
    LDT _a_ptr
    PHS
    INV _a_ptr
    LDT _a_ptr
    PHS
    INV _a_ptr
    LDT _a_ptr
    PHS
    INV _a_ptr
    LDT _a_ptr
    PHS
    INV _a_ptr
    LDT _a_ptr
    PHS
    INV _a_ptr
    LDT _a_ptr
    PHS
    INV _a_ptr
    LDT _a_ptr
    PHS
    INV _a_ptr
    LDT _a_ptr
    PHS
    INV _a_ptr

    ; Push B (LSB -> MSB)
    LDT _b_ptr
    PHS
    INV _b_ptr
    LDT _b_ptr
    PHS
    INV _b_ptr
    LDT _b_ptr
    PHS
    INV _b_ptr
    LDT _b_ptr
    PHS
    INV _b_ptr
    LDT _b_ptr
    PHS
    INV _b_ptr
    LDT _b_ptr
    PHS
    INV _b_ptr
    LDT _b_ptr
    PHS
    INV _b_ptr
    LDT _b_ptr
    PHS
    INV _b_ptr

    JPS ka64_unsigned_multiply

    MIV actual_buf,_actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    INV _actual_ptr
    MIZ 16,_cmp_count
.pop_loop:
    PLS
    STT _actual_ptr
    DEV _actual_ptr
    DEZ _cmp_count
    BNE .pop_loop
    RTS

compare_expected:
    CLZ _compare_fail
    MVV _expect_ptr,_cmp_expected_ptr
    MIV actual_buf,_cmp_actual_ptr
    INV _cmp_expected_ptr
    INV _cmp_expected_ptr
    INV _cmp_expected_ptr
    INV _cmp_expected_ptr
    INV _cmp_expected_ptr
    INV _cmp_expected_ptr
    INV _cmp_expected_ptr
    INV _cmp_expected_ptr
    INV _cmp_expected_ptr
    INV _cmp_expected_ptr
    INV _cmp_expected_ptr
    INV _cmp_expected_ptr
    INV _cmp_expected_ptr
    INV _cmp_expected_ptr
    INV _cmp_expected_ptr
    INV _cmp_actual_ptr
    INV _cmp_actual_ptr
    INV _cmp_actual_ptr
    INV _cmp_actual_ptr
    INV _cmp_actual_ptr
    INV _cmp_actual_ptr
    INV _cmp_actual_ptr
    INV _cmp_actual_ptr
    INV _cmp_actual_ptr
    INV _cmp_actual_ptr
    INV _cmp_actual_ptr
    INV _cmp_actual_ptr
    INV _cmp_actual_ptr
    INV _cmp_actual_ptr
    INV _cmp_actual_ptr
    MIZ 16,_cmp_count
.loop:
    LDT _cmp_expected_ptr
    CPR _cmp_actual_ptr
    BNE .mismatch
    DEV _cmp_expected_ptr
    DEV _cmp_actual_ptr
    DEZ _cmp_count
    BNE .loop
    RTS
.mismatch:
    INZ _compare_fail
    RTS

; sb64_unsigned_multiply
; Schoolbook 64-bit multiply using hardware 32-bit core (ml32).
; Stack: SP+3..10=multiplier, SP+11..18=multiplicand (MSB at lower address)
; Result overwrites both inputs on the stack.
sb64_unsigned_multiply:
    LDS 18
    STZ _mul64_op1+0
    LDS 17
    STZ _mul64_op1+1
    LDS 16
    STZ _mul64_op1+2
    LDS 15
    STZ _mul64_op1+3
    LDS 14
    STZ _mul64_op1+4
    LDS 13
    STZ _mul64_op1+5
    LDS 12
    STZ _mul64_op1+6
    LDS 11
    STZ _mul64_op1+7

    LDS 10
    STZ _mul64_op2+0
    LDS 9
    STZ _mul64_op2+1
    LDS 8
    STZ _mul64_op2+2
    LDS 7
    STZ _mul64_op2+3
    LDS 6
    STZ _mul64_op2+4
    LDS 5
    STZ _mul64_op2+5
    LDS 4
    STZ _mul64_op2+6
    LDS 3
    STZ _mul64_op2+7

    JPS _sb_multiplication64_schoolbook

    LDZ _mul64_result+15
    STS 3
    LDZ _mul64_result+14
    STS 4
    LDZ _mul64_result+13
    STS 5
    LDZ _mul64_result+12
    STS 6
    LDZ _mul64_result+11
    STS 7
    LDZ _mul64_result+10
    STS 8
    LDZ _mul64_result+9
    STS 9
    LDZ _mul64_result+8
    STS 10
    LDZ _mul64_result+7
    STS 11
    LDZ _mul64_result+6
    STS 12
    LDZ _mul64_result+5
    STS 13
    LDZ _mul64_result+4
    STS 14
    LDZ _mul64_result+3
    STS 15
    LDZ _mul64_result+2
    STS 16
    LDZ _mul64_result+1
    STS 17
    LDZ _mul64_result+0
    STS 18
    RTS

; ka64_unsigned_multiply
; Karatsuba 64-bit multiply using hardware 32-bit core (ml32).
; Stack: SP+3..10=multiplier, SP+11..18=multiplicand (MSB at lower address)
; Result overwrites both inputs on the stack.
ka64_unsigned_multiply:
    LDS 18
    STZ _mul64_op1+0
    LDS 17
    STZ _mul64_op1+1
    LDS 16
    STZ _mul64_op1+2
    LDS 15
    STZ _mul64_op1+3
    LDS 14
    STZ _mul64_op1+4
    LDS 13
    STZ _mul64_op1+5
    LDS 12
    STZ _mul64_op1+6
    LDS 11
    STZ _mul64_op1+7

    LDS 10
    STZ _mul64_op2+0
    LDS 9
    STZ _mul64_op2+1
    LDS 8
    STZ _mul64_op2+2
    LDS 7
    STZ _mul64_op2+3
    LDS 6
    STZ _mul64_op2+4
    LDS 5
    STZ _mul64_op2+5
    LDS 4
    STZ _mul64_op2+6
    LDS 3
    STZ _mul64_op2+7

    JPS _ka_multiplication64_karatsuba

    LDZ _mul64_result+15
    STS 3
    LDZ _mul64_result+14
    STS 4
    LDZ _mul64_result+13
    STS 5
    LDZ _mul64_result+12
    STS 6
    LDZ _mul64_result+11
    STS 7
    LDZ _mul64_result+10
    STS 8
    LDZ _mul64_result+9
    STS 9
    LDZ _mul64_result+8
    STS 10
    LDZ _mul64_result+7
    STS 11
    LDZ _mul64_result+6
    STS 12
    LDZ _mul64_result+5
    STS 13
    LDZ _mul64_result+4
    STS 14
    LDZ _mul64_result+3
    STS 15
    LDZ _mul64_result+2
    STS 16
    LDZ _mul64_result+1
    STS 17
    LDZ _mul64_result+0
    STS 18
    RTS

; _sb_multiplication32_core
; 32-bit schoolbook multiply using hardware 16-bit core.
; Inputs: _mul64_sumA (multiplicand), _mul64_sumB (multiplier)
; Output: _mul64_p (64-bit result)
_sb_multiplication32_core:
    CLQ _mul64_p
    CLQ _mul64_p+4

    ; Z0 = A0 * B0 (offset 0)
    MZB _mul64_sumA+0,MULTIPLIER_A
    MZB _mul64_sumB+0,MULTIPLIER_B
    MBZ MULTIPLIER_RESULT_LSB,_mul64_p+0
    MBZ MULTIPLIER_RESULT_MSB,_mul64_p+1

    MZB _mul64_sumA+1,MULTIPLIER_A
    MZB _mul64_sumB+1,MULTIPLIER_B
    MBZ MULTIPLIER_RESULT_LSB,_mul64_p+2
    MBZ MULTIPLIER_RESULT_MSB,_mul64_p+3

    MZB _mul64_sumA+1,MULTIPLIER_A
    MZB _mul64_sumB+0,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+1
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+2
    LDI 0
    AC.Z _mul64_p+3

    MZB _mul64_sumA+0,MULTIPLIER_A
    MZB _mul64_sumB+1,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+1
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+2
    LDI 0
    AC.Z _mul64_p+3

    ; Z3 = A1 * B1 (offset 4)
    MZB _mul64_sumA+2,MULTIPLIER_A
    MZB _mul64_sumB+2,MULTIPLIER_B
    MBZ MULTIPLIER_RESULT_LSB,_mul64_p+4
    MBZ MULTIPLIER_RESULT_MSB,_mul64_p+5

    MZB _mul64_sumA+3,MULTIPLIER_A
    MZB _mul64_sumB+3,MULTIPLIER_B
    MBZ MULTIPLIER_RESULT_LSB,_mul64_p+6
    MBZ MULTIPLIER_RESULT_MSB,_mul64_p+7

    MZB _mul64_sumA+3,MULTIPLIER_A
    MZB _mul64_sumB+2,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+5
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    MZB _mul64_sumA+2,MULTIPLIER_A
    MZB _mul64_sumB+3,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+5
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    ; Z1 = A0 * B1 (offset 2)
    MZB _mul64_sumA+0,MULTIPLIER_A
    MZB _mul64_sumB+2,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+2
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+3

    MZB _mul64_sumA+1,MULTIPLIER_A
    MZB _mul64_sumB+3,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+4
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+5

    MZB _mul64_sumA+1,MULTIPLIER_A
    MZB _mul64_sumB+2,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+3
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+4
    LDI 0
    AC.Z _mul64_p+5

    MZB _mul64_sumA+0,MULTIPLIER_A
    MZB _mul64_sumB+3,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+3
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+4
    LDI 0
    AC.Z _mul64_p+5

    LDI 0
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    ; Z2 = A1 * B0 (offset 2)
    MZB _mul64_sumA+2,MULTIPLIER_A
    MZB _mul64_sumB+0,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+2
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+3

    MZB _mul64_sumA+3,MULTIPLIER_A
    MZB _mul64_sumB+1,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+4
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+5

    MZB _mul64_sumA+3,MULTIPLIER_A
    MZB _mul64_sumB+0,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+3
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+4
    LDI 0
    AC.Z _mul64_p+5

    MZB _mul64_sumA+2,MULTIPLIER_A
    MZB _mul64_sumB+1,MULTIPLIER_B
    LDB MULTIPLIER_RESULT_LSB
    AD.Z _mul64_p+3
    LDB MULTIPLIER_RESULT_MSB
    AC.Z _mul64_p+4
    LDI 0
    AC.Z _mul64_p+5

    LDI 0
    AC.Z _mul64_p+6
    LDI 0
    AC.Z _mul64_p+7

    RTS

; sb32_unsigned_multiply_stack
; Schoolbook 32-bit multiply using hardware 16-bit core.
; Stack: SP+3..6=multiplier, SP+7..10=multiplicand (MSB at lower address)
; Result overwrites both inputs on the stack.
sb32_unsigned_multiply_stack:
    ; Copy multiplicand from stack to _mul64_sumA
    LDS 10
    STZ _mul64_sumA+0
    LDS 9
    STZ _mul64_sumA+1
    LDS 8
    STZ _mul64_sumA+2
    LDS 7
    STZ _mul64_sumA+3

    ; Copy multiplier from stack to _mul64_sumB
    LDS 6
    STZ _mul64_sumB+0
    LDS 5
    STZ _mul64_sumB+1
    LDS 4
    STZ _mul64_sumB+2
    LDS 3
    STZ _mul64_sumB+3

    JPS _sb_multiplication32_core

    ; Copy 64-bit result back to stack
    LDZ _mul64_p+7
    STS 3
    LDZ _mul64_p+6
    STS 4
    LDZ _mul64_p+5
    STS 5
    LDZ _mul64_p+4
    STS 6
    LDZ _mul64_p+3
    STS 7
    LDZ _mul64_p+2
    STS 8
    LDZ _mul64_p+1
    STS 9
    LDZ _mul64_p+0
    STS 10
    RTS

; _add64_offset4
; Adds _mul64_p into _mul64_result+4 with carry propagation into +12..+15.
_add64_offset4:
    LDZ _mul64_p+0
    AD.Z _mul64_result+4
    LDZ _mul64_p+1
    AC.Z _mul64_result+5
    LDZ _mul64_p+2
    AC.Z _mul64_result+6
    LDZ _mul64_p+3
    AC.Z _mul64_result+7
    LDZ _mul64_p+4
    AC.Z _mul64_result+8
    LDZ _mul64_p+5
    AC.Z _mul64_result+9
    LDZ _mul64_p+6
    AC.Z _mul64_result+10
    LDZ _mul64_p+7
    AC.Z _mul64_result+11
    LDI 0
    AC.Z _mul64_result+12
    LDI 0
    AC.Z _mul64_result+13
    LDI 0
    AC.Z _mul64_result+14
    LDI 0
    AC.Z _mul64_result+15
    RTS

; _sb_multiplication64_schoolbook
; 64-bit multiply using 4x 32-bit schoolbook products.
_sb_multiplication64_schoolbook:
    CLQ _mul64_result
    CLQ _mul64_result+4
    CLQ _mul64_result+8
    CLQ _mul64_result+12

    ; Z0 = A0 * B0
    LDZ _mul64_op1+0
    PHS
    LDZ _mul64_op1+1
    PHS
    LDZ _mul64_op1+2
    PHS
    LDZ _mul64_op1+3
    PHS
    LDZ _mul64_op2+0
    PHS
    LDZ _mul64_op2+1
    PHS
    LDZ _mul64_op2+2
    PHS
    LDZ _mul64_op2+3
    PHS
    JPS sb32_unsigned_multiply_stack
    LDS 10
    STZ _mul64_result+0
    LDS 9
    STZ _mul64_result+1
    LDS 8
    STZ _mul64_result+2
    LDS 7
    STZ _mul64_result+3
    LDS 6
    STZ _mul64_result+4
    LDS 5
    STZ _mul64_result+5
    LDS 4
    STZ _mul64_result+6
    LDS 3
    STZ _mul64_result+7
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS

    ; Z3 = A1 * B1
    LDZ _mul64_op1+4
    PHS
    LDZ _mul64_op1+5
    PHS
    LDZ _mul64_op1+6
    PHS
    LDZ _mul64_op1+7
    PHS
    LDZ _mul64_op2+4
    PHS
    LDZ _mul64_op2+5
    PHS
    LDZ _mul64_op2+6
    PHS
    LDZ _mul64_op2+7
    PHS
    JPS sb32_unsigned_multiply_stack
    LDS 10
    STZ _mul64_result+8
    LDS 9
    STZ _mul64_result+9
    LDS 8
    STZ _mul64_result+10
    LDS 7
    STZ _mul64_result+11
    LDS 6
    STZ _mul64_result+12
    LDS 5
    STZ _mul64_result+13
    LDS 4
    STZ _mul64_result+14
    LDS 3
    STZ _mul64_result+15
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS

    ; Z1 = A0 * B1
    LDZ _mul64_op1+0
    PHS
    LDZ _mul64_op1+1
    PHS
    LDZ _mul64_op1+2
    PHS
    LDZ _mul64_op1+3
    PHS
    LDZ _mul64_op2+4
    PHS
    LDZ _mul64_op2+5
    PHS
    LDZ _mul64_op2+6
    PHS
    LDZ _mul64_op2+7
    PHS
    JPS sb32_unsigned_multiply_stack
    LDS 10
    STZ _mul64_p+0
    LDS 9
    STZ _mul64_p+1
    LDS 8
    STZ _mul64_p+2
    LDS 7
    STZ _mul64_p+3
    LDS 6
    STZ _mul64_p+4
    LDS 5
    STZ _mul64_p+5
    LDS 4
    STZ _mul64_p+6
    LDS 3
    STZ _mul64_p+7
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    JPS _add64_offset4

    ; Z2 = A1 * B0
    LDZ _mul64_op1+4
    PHS
    LDZ _mul64_op1+5
    PHS
    LDZ _mul64_op1+6
    PHS
    LDZ _mul64_op1+7
    PHS
    LDZ _mul64_op2+0
    PHS
    LDZ _mul64_op2+1
    PHS
    LDZ _mul64_op2+2
    PHS
    LDZ _mul64_op2+3
    PHS
    JPS sb32_unsigned_multiply_stack
    LDS 10
    STZ _mul64_p+0
    LDS 9
    STZ _mul64_p+1
    LDS 8
    STZ _mul64_p+2
    LDS 7
    STZ _mul64_p+3
    LDS 6
    STZ _mul64_p+4
    LDS 5
    STZ _mul64_p+5
    LDS 4
    STZ _mul64_p+6
    LDS 3
    STZ _mul64_p+7
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    JPS _add64_offset4

    RTS

; _ka_multiplication64_karatsuba
; 64-bit multiply using Karatsuba (3x 32-bit products).
.align
_ka_multiplication64_karatsuba:
    ; Z0 = A0 * B0
    LDZ _mul64_op1+0
    PHS
    LDZ _mul64_op1+1
    PHS
    LDZ _mul64_op1+2
    PHS
    LDZ _mul64_op1+3
    PHS
    LDZ _mul64_op2+0
    PHS
    LDZ _mul64_op2+1
    PHS
    LDZ _mul64_op2+2
    PHS
    LDZ _mul64_op2+3
    PHS
    JPS ml32_unsigned_multiply
    LDS 10
    STZ _mul64_result+0
    LDS 9
    STZ _mul64_result+1
    LDS 8
    STZ _mul64_result+2
    LDS 7
    STZ _mul64_result+3
    LDS 6
    STZ _mul64_result+4
    LDS 5
    STZ _mul64_result+5
    LDS 4
    STZ _mul64_result+6
    LDS 3
    STZ _mul64_result+7
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS

    ; Z2 = A1 * B1
    LDZ _mul64_op1+4
    PHS
    LDZ _mul64_op1+5
    PHS
    LDZ _mul64_op1+6
    PHS
    LDZ _mul64_op1+7
    PHS
    LDZ _mul64_op2+4
    PHS
    LDZ _mul64_op2+5
    PHS
    LDZ _mul64_op2+6
    PHS
    LDZ _mul64_op2+7
    PHS
    JPS ml32_unsigned_multiply
    LDS 10
    STZ _mul64_result+8
    LDS 9
    STZ _mul64_result+9
    LDS 8
    STZ _mul64_result+10
    LDS 7
    STZ _mul64_result+11
    LDS 6
    STZ _mul64_result+12
    LDS 5
    STZ _mul64_result+13
    LDS 4
    STZ _mul64_result+14
    LDS 3
    STZ _mul64_result+15
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS

    ; sumA = A0 + A1
    CLZ _mul64_sumA_carry
    MQQ _mul64_op1+0,_mul64_sumA
    LDZ _mul64_op1+4
    AD.Z _mul64_sumA+0
    LDZ _mul64_op1+5
    AC.Z _mul64_sumA+1
    LDZ _mul64_op1+6
    AC.Z _mul64_sumA+2
    LDZ _mul64_op1+7
    AC.Z _mul64_sumA+3
    BCC .no_carry_a
    INZ _mul64_sumA_carry
.no_carry_a:

    ; sumB = B0 + B1
    CLZ _mul64_sumB_carry
    MQQ _mul64_op2+0,_mul64_sumB
    LDZ _mul64_op2+4
    AD.Z _mul64_sumB+0
    LDZ _mul64_op2+5
    AC.Z _mul64_sumB+1
    LDZ _mul64_op2+6
    AC.Z _mul64_sumB+2
    LDZ _mul64_op2+7
    AC.Z _mul64_sumB+3
    BCC .no_carry_b
    INZ _mul64_sumB_carry
.no_carry_b:

    ; P = sumA * sumB
    LDZ _mul64_sumA+0
    PHS
    LDZ _mul64_sumA+1
    PHS
    LDZ _mul64_sumA+2
    PHS
    LDZ _mul64_sumA+3
    PHS
    LDZ _mul64_sumB+0
    PHS
    LDZ _mul64_sumB+1
    PHS
    LDZ _mul64_sumB+2
    PHS
    LDZ _mul64_sumB+3
    PHS
    JPS ml32_unsigned_multiply
    LDS 10
    STZ _mul64_p+0
    LDS 9
    STZ _mul64_p+1
    LDS 8
    STZ _mul64_p+2
    LDS 7
    STZ _mul64_p+3
    LDS 6
    STZ _mul64_p+4
    LDS 5
    STZ _mul64_p+5
    LDS 4
    STZ _mul64_p+6
    LDS 3
    STZ _mul64_p+7
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS
    PLS

    CLZ _mul64_p_hi

    ; if sumA_carry: add sumB << 32 to P
    CIZ 0, _mul64_sumA_carry
    BEQ .skip_add_b
    LDZ _mul64_sumB+0
    AD.Z _mul64_p+4
    LDZ _mul64_sumB+1
    AC.Z _mul64_p+5
    LDZ _mul64_sumB+2
    AC.Z _mul64_p+6
    LDZ _mul64_sumB+3
    AC.Z _mul64_p+7
    BCC .no_pcarry1
    INZ _mul64_p_hi
.no_pcarry1:
.skip_add_b:

    ; if sumB_carry: add sumA << 32 to P
    CIZ 0, _mul64_sumB_carry
    BEQ .skip_add_a
    LDZ _mul64_sumA+0
    AD.Z _mul64_p+4
    LDZ _mul64_sumA+1
    AC.Z _mul64_p+5
    LDZ _mul64_sumA+2
    AC.Z _mul64_p+6
    LDZ _mul64_sumA+3
    AC.Z _mul64_p+7
    BCC .no_pcarry2
    INZ _mul64_p_hi
.no_pcarry2:
.skip_add_a:

    ; if sumA_carry & sumB_carry: add 1<<64
    CIZ 0, _mul64_sumA_carry
    BEQ .skip_ab
    CIZ 0, _mul64_sumB_carry
    BEQ .skip_ab
    INZ _mul64_p_hi
.skip_ab:

    ; P = P - Z0 (adjust p_hi for borrows)
    LDZ _mul64_result+0
    SU.Z _mul64_p+0
    LDZ _mul64_result+1
    SC.Z _mul64_p+1
    LDZ _mul64_result+2
    SC.Z _mul64_p+2
    LDZ _mul64_result+3
    SC.Z _mul64_p+3
    LDZ _mul64_result+4
    SC.Z _mul64_p+4
    LDZ _mul64_result+5
    SC.Z _mul64_p+5
    LDZ _mul64_result+6
    SC.Z _mul64_p+6
    LDZ _mul64_result+7
    SC.Z _mul64_p+7
    BCS .no_borrow0
.borrow0:
    DEZ _mul64_p_hi
.no_borrow0:

    ; P = P - Z2 (adjust p_hi for borrows)
    LDZ _mul64_result+8
    SU.Z _mul64_p+0
    LDZ _mul64_result+9
    SC.Z _mul64_p+1
    LDZ _mul64_result+10
    SC.Z _mul64_p+2
    LDZ _mul64_result+11
    SC.Z _mul64_p+3
    LDZ _mul64_result+12
    SC.Z _mul64_p+4
    LDZ _mul64_result+13
    SC.Z _mul64_p+5
    LDZ _mul64_result+14
    SC.Z _mul64_p+6
    LDZ _mul64_result+15
    SC.Z _mul64_p+7
    BCS .no_borrow1
.borrow1:
    DEZ _mul64_p_hi
.no_borrow1:

    ; add Z1 (P << 32)
    LDZ _mul64_p+0
    AD.Z _mul64_result+4
    LDZ _mul64_p+1
    AC.Z _mul64_result+5
    LDZ _mul64_p+2
    AC.Z _mul64_result+6
    LDZ _mul64_p+3
    AC.Z _mul64_result+7
    LDZ _mul64_p+4
    AC.Z _mul64_result+8
    LDZ _mul64_p+5
    AC.Z _mul64_result+9
    LDZ _mul64_p+6
    AC.Z _mul64_result+10
    LDZ _mul64_p+7
    AC.Z _mul64_result+11
    LDI 0
    AC.Z _mul64_result+12
    LDI 0
    AC.Z _mul64_result+13
    LDI 0
    AC.Z _mul64_result+14
    LDI 0
    AC.Z _mul64_result+15

    ; add p_hi (extra Z1 bits above 64)
    CLC
    LDZ _mul64_p_hi
    AD.Z _mul64_result+12
    LDI 0
    AC.Z _mul64_result+13
    LDI 0
    AC.Z _mul64_result+14
    LDI 0
    AC.Z _mul64_result+15

    RTS

actual_buf:
    .16byte 0

test0_a:
    .8byte 0x0000000000000000
test0_b:
    .8byte 0x123456789ABCDEF0
test0_expect:
    .16byte 0x00000000000000000000000000000000

test1_a:
    .8byte 0x0000000000000001
test1_b:
    .8byte 0xFFFFFFFFFFFFFFFF
test1_expect:
    .16byte 0x0000000000000000FFFFFFFFFFFFFFFF

test2_a:
    .8byte 0xFFFFFFFFFFFFFFFF
test2_b:
    .8byte 0xFFFFFFFFFFFFFFFF
test2_expect:
    .16byte 0xFFFFFFFFFFFFFFFE0000000000000001

test3_a:
    .8byte 0x00000000FFFFFFFF
test3_b:
    .8byte 0x00000000FFFFFFFF
test3_expect:
    .16byte 0x0000000000000000FFFFFFFE00000001

test4_a:
    .8byte 0xFFFFFFFF00000000
test4_b:
    .8byte 0x00000000FFFFFFFF
test4_expect:
    .16byte 0x00000000FFFFFFFE0000000100000000

test5_a:
    .8byte 0x8000000000000000
test5_b:
    .8byte 0x8000000000000000
test5_expect:
    .16byte 0x40000000000000000000000000000000

test6_a:
    .8byte 0x123456789ABCDEF0
test6_b:
    .8byte 0x0FEDCBA987654321
test6_expect:
    .16byte 0x0121FA00AD77D7422236D88FE5618CF0

test7_a:
    .8byte 0xFFFFFFFFFFFFFFFF
test7_b:
    .8byte 0x0000000100000001
test7_expect:
    .16byte 0x0000000100000000FFFFFFFEFFFFFFFF

#include "mathlib32.min64x4"
