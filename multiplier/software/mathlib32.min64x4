#require __LANGUAGE_NAME__ == slu4-min64x4-asm
#require __LANGUAGE_VERSION__ >= 1.1.0
#create-scope "mathlib32" prefix="ml32_"

.memzone ZERO_PAGE_LIBS
#mute
; 32-bit multiplication variables
_mul32_op1:         .4byte 0    ; First operand (multiplicand)
_mul32_op2:         .4byte 0    ; Second operand (multiplier)
_mul32_result:      .8byte 0    ; 64-bit result
_mul32_sign_flag:   .byte 0     ; Sign flag for signed multiplication

#ifndef USE_ACCELERATOR
; Software version variables
_mul32_counter:     .byte 0     ; Loop counter
_mul32_multiplicand:.8byte 0     ; Shifted 64-bit multiplicand
#else
; Karatsuba temp flags/accumulator (hardware path)
_mul32_k_sumA_carry:.byte 0  ; carry-out of A0+A1
_mul32_k_sumB_carry:.byte 0  ; carry-out of B0+B1
_mul32_k_p_hi:      .byte 0  ; extra bit(s) above P[31:0]
_mul16_op1:         .2byte 0
_mul16_op2:         .2byte 0
_mul16_result:      .4byte 0
#endif


#ifdef USE_ACCELERATOR
#ifndef MULTIPLIER_A
; Hardware multiplier accelerator memory-mapped registers
MULTIPLIER_A = $FED0            ; Input register for 8-bit multiplicand A
MULTIPLIER_B = $FED1            ; Input register for 8-bit multiplicand B
MULTIPLIER_RESULT_LSB = $FED2   ; Output register for LSB of 16-bit result
MULTIPLIER_RESULT_MSB = $FED3   ; Output register for MSB of 16-bit result
#endif
#endif

#emit
.memzone USER_APPS
.align

; Negates a 64-bit number in place (2's complement)
; Expects the number in _mul32_result
_negate64:
    ; Perform 1's complement (NOT)
    NOQ _mul32_result       ; NOT lower 32 bits
    NOQ _mul32_result+4     ; NOT upper 32 bits
    ; Add 1 to get 2's complement, with carry propagation
    INZ _mul32_result+0
    FCC .neg_done           ; Branch if carry is clear (no rollover)
    INZ _mul32_result+1
    FCC .neg_done
    INZ _mul32_result+2
    FCC .neg_done
    INZ _mul32_result+3
    FCC .neg_done
    INZ _mul32_result+4
    FCC .neg_done
    INZ _mul32_result+5
    FCC .neg_done
    INZ _mul32_result+6
    FCC .neg_done
    INZ _mul32_result+7
.neg_done:
    RTS

#ifdef USE_ACCELERATOR
#print magenta "Compiling hardware accelerated 32-bit multiplication"
.align
; Core 32x32 hardware accelerated multiplication.
; Multiplies _mul32_op1 by _mul32_op2, stores result in _mul32_result.
; uses Karatsuba's algorithm  to speed up results.
;
;   Z0 = A0*B0
;   Z1 = (A1 + A0)*(B1 + B0) - Z2 - Z0
;   Z2 = A1*B1
;
;   R = Z2*2^32 + Z1*2^16 + Z0
_multiplication32_core:
    ; Z0
    MVV _mul32_op1+0,_mul16_op1
    MVV _mul32_op2+0,_mul16_op2
    JPS _multiplication16
    MQQ _mul16_result,_mul32_result+0

    ; Z2
    MVV _mul32_op1+2,_mul16_op1
    MVV _mul32_op2+2,_mul16_op2
    JPS _multiplication16
    MQQ _mul16_result,_mul32_result+4

    ; Z1
    ; Z1 (carry-corrected Karatsuba)
    ; sumA = A0 + A1, sumB = B0 + B1
    CLZ _mul32_k_sumA_carry
    MVV _mul32_op1+0,_mul16_op1
    AVV _mul32_op1+2,_mul16_op1
    FCC .no_carry_a
    INZ _mul32_k_sumA_carry
.no_carry_a:

    CLZ _mul32_k_sumB_carry
    MVV _mul32_op2+0,_mul16_op2
    AVV _mul32_op2+2,_mul16_op2
    FCC .no_carry_b
    INZ _mul32_k_sumB_carry
.no_carry_b:

    JPS _multiplication16

    CLZ _mul32_k_p_hi

    ; if sumA_carry: add sumB_lo << 16 to P
    CIZ 0, _mul32_k_sumA_carry
    FEQ .skip_add_b
    AVV _mul16_op2,_mul16_result+2
    FCC .no_pcarry1
    INZ _mul32_k_p_hi
.no_pcarry1:
.skip_add_b:

    ; if sumB_carry: add sumA_lo << 16 to P
    CIZ 0, _mul32_k_sumB_carry
    FEQ .skip_add_a
    AVV _mul16_op1,_mul16_result+2
    FCC .no_pcarry2
    INZ _mul32_k_p_hi
.no_pcarry2:
.skip_add_a:

    ; if sumA_carry & sumB_carry: add 1<<32
    CIZ 0, _mul32_k_sumA_carry
    FEQ .skip_ab
    CIZ 0, _mul32_k_sumB_carry
    FEQ .skip_ab
    INZ _mul32_k_p_hi
.skip_ab:

    ; Z1 = P - Z0 - Z2 (adjust p_hi for borrows)
    SQQ _mul32_result+0,_mul16_result
    FCC .borrow0
    FPA .no_borrow0
.borrow0:
    DEZ _mul32_k_p_hi
.no_borrow0:
    SQQ _mul32_result+4,_mul16_result
    FCC .borrow1
    FPA .no_borrow1
.borrow1:
    DEZ _mul32_k_p_hi
.no_borrow1:

    ; add it in (Z1 << 16)
    AQQ _mul16_result,_mul32_result+2
    LDZ _mul32_k_p_hi
    AC.Z _mul32_result+6
    LDI 0
    AC.Z _mul32_result+7

    RTS

_multiplication16:

    MZB _mul16_op1+0,MULTIPLIER_A                   ; MZB = 7 clock cycles
    MZB _mul16_op2+0,MULTIPLIER_B                   ; MZB = 7 clock cycles

    ; Read 16-bit result from hardware into low work of final result
    MBZ MULTIPLIER_RESULT_LSB,_mul16_result+0       ; MBZ = 7 clock cycles
    MBZ MULTIPLIER_RESULT_MSB,_mul16_result+1       ; MBZ = 7 clock cycles

    ; Perform A_high × B_high (contributes to result bits 16-31)
    MZB _mul16_op1+1,MULTIPLIER_A                   ; MZB = 7 clock cycles
    MZB _mul16_op2+1,MULTIPLIER_B                   ; MZB = 7 clock cycles

    ; Read 16-bit result from hardware in high word of final result
    MBZ MULTIPLIER_RESULT_LSB,_mul16_result+2        ; MBZ = 7 clock cycles
    MBZ MULTIPLIER_RESULT_MSB,_mul16_result+3        ; MBZ = 7 clock cycles

    ; Perform A_high × B_low (contributes to result bits 8-23)
    MZB _mul16_op1+1,MULTIPLIER_A                   ; MZB = 7 clock cycles
    MZB _mul16_op2+0,MULTIPLIER_B                   ; MZB = 7 clock cycles

    ; Add 16-bit result directly to _mul_result at byte offset 1
    LDB MULTIPLIER_RESULT_LSB       ; A = result LSB, 5 clock cycles
    AD.Z _mul16_result+1            ; Add to _mul_result[1], store result in _mul_result[1], 4 clock cycles
    LDB MULTIPLIER_RESULT_MSB       ; A = result MSB, 5 clock cycles
    AC.Z _mul16_result+2            ; Add with carry to _mul_result[2], store result in _mul_result[2], 4 clock cycles
    LDI 0                           ; A = 0 (for carry propagation), 2 clock cycles
    AC.Z _mul16_result+3            ; Add carry to byte 3 (0 + carry), 4 clock cycles

    ; Perform A_low × B_high (contributes to result bits 8-23)
    MZB _mul16_op1+0,MULTIPLIER_A                   ; MZB = 7 clock cycles
    MZB _mul16_op2+1,MULTIPLIER_B                   ; MZB = 7 clock cycles

    ; Add 16-bit result directly to _mul_result at byte offset 1
    LDB MULTIPLIER_RESULT_LSB       ; A = result LSB, 5 clock cycles
    AD.Z _mul16_result+1            ; Add to _mul_result[1], store result in _mul_result[1], 4 clock cycles
    LDB MULTIPLIER_RESULT_MSB       ; A = result MSB, 5 clock cycles
    AC.Z _mul16_result+2            ; Add with carry to _mul_result[2], store result in _mul_result[2], 4 clock cycles
    LDI 0                           ; A = 0 (for carry propagation), 2 clock cycles
    AC.Z _mul16_result+3            ; Add carry to byte 3 (0 + carry), 4 clock cycles

    RTS

#else
#print yellow "Compiling software-only 32-bit multiplication"

; Adds 64-bit value in _mul32_multiplicand to _mul32_result
_add64_to_result:
    LDZ _mul32_multiplicand+0
    AD.Z _mul32_result+0
    LDZ _mul32_multiplicand+1
    AC.Z _mul32_result+1
    LDZ _mul32_multiplicand+2
    AC.Z _mul32_result+2
    LDZ _mul32_multiplicand+3
    AC.Z _mul32_result+3
    LDZ _mul32_multiplicand+4
    AC.Z _mul32_result+4
    LDZ _mul32_multiplicand+5
    AC.Z _mul32_result+5
    LDZ _mul32_multiplicand+6
    AC.Z _mul32_result+6
    LDZ _mul32_multiplicand+7
    AC.Z _mul32_result+7
    RTS

; Core 32x32 software multiplication (shift-and-add)
_multiplication32_core:
    CLQ _mul32_result
    CLQ _mul32_result+4

    ; Optimization: check for zero multiplier
    LDZ _mul32_op2+3
    ORZ _mul32_op2+2
    ORZ _mul32_op2+1
    ORZ _mul32_op2+0
    CPI 0
    FEQ .done ; If multiplier is 0, result is 0, so exit

    CLQ _mul32_multiplicand
    CLQ _mul32_multiplicand+4

    ; Copy operand 1 to the low 32 bits of the 64-bit multiplicand
    MVV _mul32_op1, _mul32_multiplicand
    MVV _mul32_op1+2, _mul32_multiplicand+2

    ; Optimization: set loop counter based on multiplier size
    CIZ 0, _mul32_op2+3
    FNE .full_32_bits
    CIZ 0, _mul32_op2+2
    FNE .use_24_bits
    CIZ 0, _mul32_op2+1
    FNE .use_16_bits

    ; Only LSB is non-zero
    MIZ 8, _mul32_counter
    FPA .mul_loop

.use_16_bits:
    MIZ 16, _mul32_counter
    FPA .mul_loop

.use_24_bits:
    MIZ 24, _mul32_counter
    FPA .mul_loop

.full_32_bits:
    MIZ 32, _mul32_counter

.mul_loop:
    ; Right shift 32-bit multiplier to check LSB
    CLC
    RRZ _mul32_op2+3  ; MSB
    RRZ _mul32_op2+2
    RRZ _mul32_op2+1
    RRZ _mul32_op2+0  ; LSB
    FCC .no_add             ; If LSB was 0, skip the add

    JPS _add64_to_result    ; Add multiplicand to result

.no_add:
    ; Left shift 64-bit multiplicand (happens every iteration)
    LLV _mul32_multiplicand
    RLV _mul32_multiplicand+2
    RLV _mul32_multiplicand+4
    RLV _mul32_multiplicand+6

    DEZ _mul32_counter
    FNE .mul_loop

.done:
    RTS

#endif

; ml32_unsigned_multiply
; Multiplies two unsigned 32-bit integers. Result is 64-bit.
; Stack: SP+3..6=multiplier, SP+7..10=multiplicand (MSB at lower address)
; Result overwrites both inputs on the stack.
ml32_unsigned_multiply:
    ; Copy multiplicand from stack to _mul32_op1
    LDS 10
    STZ _mul32_op1+0
    LDS 9
    STZ _mul32_op1+1
    LDS 8
    STZ _mul32_op1+2
    LDS 7
    STZ _mul32_op1+3

    ; Copy multiplier from stack to _mul32_op2
    LDS 6
    STZ _mul32_op2+0
    LDS 5
    STZ _mul32_op2+1
    LDS 4
    STZ _mul32_op2+2
    LDS 3
    STZ _mul32_op2+3

    JPS _multiplication32_core

    ; Copy 64-bit result back to stack
    LDZ _mul32_result+7
    STS 3
    LDZ _mul32_result+6
    STS 4
    LDZ _mul32_result+5
    STS 5
    LDZ _mul32_result+4
    STS 6
    LDZ _mul32_result+3
    STS 7
    LDZ _mul32_result+2
    STS 8
    LDZ _mul32_result+1
    STS 9
    LDZ _mul32_result+0
    STS 10

    RTS

; ml32_signed_multiply
; Multiplies two signed 32-bit integers. Result is 64-bit.
ml32_signed_multiply:
    ; Copy multiplicand from stack to _mul32_op1
    LDS 10
    STZ _mul32_op1+0
    LDS 9
    STZ _mul32_op1+1
    LDS 8
    STZ _mul32_op1+2
    LDS 7
    STZ _mul32_op1+3

    CLZ _mul32_sign_flag

    ; Check sign of first operand
    LDZ _mul32_op1+3
    ANI $80
    FEQ .check_second_sign
    INZ _mul32_sign_flag    ; Flip sign
    NEQ _mul32_op1          ; Negate 32-bit operand

.check_second_sign:
    ; Copy multiplier from stack to _mul32_op2
    LDS 6
    STZ _mul32_op2+0
    LDS 5
    STZ _mul32_op2+1
    LDS 4
    STZ _mul32_op2+2
    LDS 3
    STZ _mul32_op2+3

    ; Check sign of second operand
    LDZ _mul32_op2+3
    ANI $80
    FEQ .do_multiply
    LDI 1
    XR.Z _mul32_sign_flag ; Flip sign if different
    NEQ _mul32_op2

.do_multiply:
    JPS _multiplication32_core

    CIZ 0, _mul32_sign_flag
    FEQ .return_result
    JPS _negate64           ; Negate 64-bit result

.return_result:
    ; Copy 64-bit result back to stack
    LDZ _mul32_result+7
    STS 3
    LDZ _mul32_result+6
    STS 4
    LDZ _mul32_result+5
    STS 5
    LDZ _mul32_result+4
    STS 6
    LDZ _mul32_result+3
    STS 7
    LDZ _mul32_result+2
    STS 8
    LDZ _mul32_result+1
    STS 9
    LDZ _mul32_result+0
    STS 10

    RTS
